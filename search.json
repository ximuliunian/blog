[{"title":"Git常用命令","url":"/2022/08/28/Git/Git%E5%91%BD%E4%BB%A4/","content":"Git命令版本库其实就是Git管理文件的仓库， 通俗点说就是一个目录，不过在这个目录里面， 所有的文件都在被Git管理， 包括每个文件的修改和删除，都能找到对应的操作记录， 对于新增的文件，要先添加到版本库中才能被Git管理起来\n编写一个文本文件并提交到Git仓库\ngit rm 文件名 删除文件\nclear 清屏\nCTRL+INS(INSERT) 复制\nSHIFT+INS(INSERT) 粘贴\n初始化Git本地仓库执行 git init 命令在本地初始化本地仓库(空仓库)\n执行 git add 命令添加文件到暂存区\n\ngit add [file1] [file2] …\n\n添加一个或多个文件到暂存区\n\n\ngit add [dir]\n\n添加指定目录到暂存区，包括子目录\n\n\ngit add .\n\n添加当前目录下的所有文件到暂存区\n\n\n\n文件被添加到暂存区后,执行 git commit 命令提交暂存区文件到本地库中\n\ngit commit -m [message]\n\n提交暂存区到本地仓库中\n[message] 可以是一些备注信息\n\n\ngit commit [file1] [file2] … -m [message]\n\n提交暂存区的指定文件到仓库区\n\n\ngit commit -a\n\n-a 参数设置修改文件后不需要执行 git add 命令，直接来提交\n\n\n\n查看信息git log 命令用于显示提交日志信息\n\ngit log –pretty&#x3D;oneline\n让版本记录在一行显示\n\ngit status 查看工作目录与暂存区文件状态\ngit ls-files 查看Git本地仓库里的文件目录\ngit reflog 查看所有日志信息\n比较与撤销\ngit diff HEAD –文件\n\n查看这个文件和版本库里面的文件进行比较\n\n\ngit restore –staged 文件\n\n暂存区文件中撤销掉不想添加的文件(可以多个撤销)\n\n\ngit reset HEAD 文件\n\n撤销上一次的操作\n\n\n\n时光回溯\ngit reset –hard HEAD\n\n回退到上一个版本(一个^就是回退到上一个版本 两个^就是回退到上两个版本 以此类推)\n\n\ngit reset –hard HEAD~数字\n\n数字填几就会退到哪个版本\n\n\ngit reset –hard 唯一标识\n\n回退或前进到指定版本(唯一标识字数要≥8)\n\n\n\n若是回退到版本之后,前面的版本不显示了,可以用git reflog让其进行显示\n远程\ngit clone 地址\n\n克隆某个远程仓库到本地\n\n\ngit remote add origin 地址\n\n绑定远程仓库\n\n\ngit push -u origin 分支名\n\n推送到远程仓库 之后可以用 git push\n\n\ngit branch -a\n\n查看远程分支\n\n\n\n分支\ngit branch\n\n查看本地分支 带*的之目前所在的分支\n\n\ngit checkout -b 名字\n\n创建分支并切换到该分支\n\n\ngit checkout 名字\n\n切换分支\n\n\ngit branch -m 名字 名字\n\n分支重命名 前面的名字是重命名前的 后面的名字是重命名后的新名字\n-m可以换成-M -M是强制重命名(这个名字的分支已经存在了,但我要强制命名为它)\n\n\ngit merge 名字\n\n合并分支(合并分支的时候一定要切换到要合并的分支上,不能在被合并的分支上进行合并)\n\n\ngit branch -d 名字\n\n除册分支\n-d可以换成-D -D是强制删除\n\n\ngit push origin 分支名字\n\n推送本地分支到远程\n\n\ngit push origin **:**分支名字\n\n删除远程分支(本地还在保留)\n\n\ngit fetch\n\n获取远程仓库的最新状态(拉取远程分支时不显示分支可解决)\n\n\ngit checkout -b 名字 origin&#x2F;名字\n\n拉取远程分支 两个名字(分支名字)是一样的的\n\n\n\n标签\ngit tab\n\n查看所有的标签\n\n\ngit tag 标签\n\n新建标签 默认是最后一次提交记录\n\n\ngit tag 标签 唯一标识\n\n给选定的记录新建标签\n\n\ngit tag -a 标签 -m ‘描述’ 唯一标识\n\n给选定的记录加标签并加描述\n\n\ngit push origin 标签\n\n推送指定标签到远程\n\n\ngit push origin –tags\n\n推送所有未推送的标签到远程\n\n\ngit push origin :refs&#x2F;tags&#x2F;标签\n\n除册远程标签\n\n\ngit tag -d 标签\n\n除册本地标签\n\n\n\n","categories":["Git"],"tags":["小知识","工具","命令"]},{"title":"Git简介","url":"/2022/08/28/Git/Git%E7%AE%80%E4%BB%8B/","content":"前言什么是Git\nGit是目前世界上最先进的分布式版本控制系统（没有之一）。  Git 是一个开源的分布式版本控制软件,用以有效、 高速的处理从很小到非常大的项目版本管理。  Git 最初是由Linus Torvalds设计开发的，用于管理Linux内核开发。 Git 是根据GNU通用公共许可证版本2的条款分发的自由&#x2F;免费软件\nGit和Linux的开发者是同一人\n版本控制版本控制最主要的功能就是追踪文件的变更。 它将什么时候、什么人更改了文件的什么内容等信息忠实地了记录下来。 每一次文件的改变，文件的版本号都将增加。 除了记录版本变更外，版本控制的另一个重要功能是并行开发。 软件开发 往往是多人协同作业，版本控制可以有效地解决版本的同步以及不同开发者之间的开发通信问题，提高协同开发的效率。 并行开发中最常见的不同版本软件的错误 (Bug)修正问题也可以通过版本控制中分支与合并的方法有效地解决。 具体来说，在每一项开发任务中，都需要首先设定开发基线，确定各个配置项的开发初始版本，在开发过程中， 开发人员基于开发基线的版本，开发出所需的目标版本\n本地版本控制系统\n好处：简单\n坏处：容易犯错,有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件\n集中化版本控制系统\n好处：每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限\n坏处： 要是服务器宕机了那么所有人都不能提交或者拉取, 要是硬盘损坏了又没有备份,那么所提交的数据什么的全完了, 本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置， 就有丢失所有历史更新记录的风险\n分布式版本控制系统\n分布式版本控制系统（Distributed Version Control System， DVCS）。 在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs等， 客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份\nWin系统安装GitGit最开始是在Linux系统上运行的,很长一段时间内也只能在Linux系统上运行,后来才有人把它慢慢的移动到Windows系统上\nWindows系统上使用Git得先从官网上下载安装程序\n官网：https://git-scm.com\n安装完成之后在DOS(win+r,输入cmd)窗口输入git,如果出现以下界面表示安装成功\n\n可以右键选择Git Bash Here运行Git\n在Git窗口输入\ngit --version\n\n来查看Git当前版本\n\n配置Git因为提交代码要确认是谁提交的,什么人在什么时间段干了什么事。\ngit config --global user.name &#x27;里面输入你的名字&#x27;git config --global user.email &#x27;里面输入你的邮箱&#x27;git config --list   查看所有配置\n\n\n注意： git config 命令的 –global 参数,用了这个参数,表示你这台机器上的所有的Git仓库都会使用这个配置,当然也可以对某个仓库指定不同的用户名和email地址\n\n理解Git文件的三种状态与工作模式使用Git操作文件时,文件的状态有以下三种\n\n\n\n单位\n描述\n\n\n\n已提交 (committed)\n表示数据已经保存在本地的数据库中\n\n\n已修改 (modified)\n表示修改了文件,但还没有保存到数据库中\n\n\n已暂存 (staged)\n表示对一个已修改文件的当前版本做了标记,使之包含在下次提交的快照中\n\n\n针对Git文件的三种状态\n\n\n\n分类\n描述\n\n\n\n工作区\n简单的理解为在电脑能看到的目录,比如自己创建的本地项目目录\n\n\n暂存区\nGit的版本库里存了很多东西,其中最重要的就是称为stage(或者叫index)的暂存区,还有Git自动创建的一个分支master,以及指向master的一个指针叫HEAD\n\n\nGit仓库\n工作区有一个隐藏目录.git,这个不算工作区,而是Git的版本等\n\n\nGit工作原理\n在工作区修改了某些文件\n对修改后的文件进行快照\n提交更新,将保存在暂存区的文件快照永久储存到Git仓库中\n\n\n","categories":["Git"],"tags":["小知识","工具"]},{"title":"Git配置远程SSH连接","url":"/2023/03/10/Git/Git%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8BSSH%E8%BF%9E%E6%8E%A5/","content":"关于SSHSSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。使用 SSH 协议可以连接远程服务器和服务并向它们验证。连接远程仓库时无需输入密码而且能实现对 github 的流畅访问\n安全外壳协议,安全外壳协议（Secure Shell，简称SSH）是一种在不安全网络上用于安全远程登录和其他安全网络服务的协议\n查看现有的SSHWindows打开Git Bash，Linux打开终端输入：\nls -al ~/.ssh\n\n看到这个证明已经有 ssh 密钥（以 .pub 结尾的文件）\n$ ls -al ~/.sshtotal 25drwxr-xr-x 1 Administrator 197121    0 Mar 10 11:53 ./drwxr-xr-x 1 Administrator 197121    0 Mar 10 15:39 ../-rw-r--r-- 1 Administrator 197121 3381 Mar 10 11:51 id_rsa-rw-r--r-- 1 Administrator 197121  743 Mar 10 11:51 id_rsa.pub-rw-r--r-- 1 Administrator 197121  656 Mar 10 11:53 known_hosts-rw-r--r-- 1 Administrator 197121   92 Mar 10 11:53 known_hosts.old\n\n文件一般是在C盘下的用户–&gt;你的名字–&gt;.ssh目录下\n创建一个新的SSH秘钥Windows打开Git Bash，Linux打开终端输入：\nssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;\n\n你可以把引号里的替换为你自己的邮箱，不换的话问题不大，然后终端会让你输入一些东西，不用管他，一直回车下一步\n当显示这个的时候，证明创建成功\nGenerating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /root/.ssh/id_rsaYour public key has been saved in /root/.ssh/id_rsa.pubThe key fingerprint is:SHA256:t3925EJgD4kcUp69dBv/nqkM85n0I5mFRW4BlZwaVeo your_email@example.comThe key&#x27;s randomart image is:+---[RSA 4096]----+|             .=o=||          .  . B ||         o +  * .||        . * =oo+ ||        So.B +A+ ||         .o.B.o.o||          .o o+o.||           .*+B.*||            .OoBo|+----[SHA256]-----+\n\n绑定GitHub复制秘钥首先在终端里面输入已下指令会显示出的一堆字符串，赋值这个字符串\ncat ~/.ssh/id_rsa.pub\n\nWindows用户可以在C盘目录下的Users(用户)文件夹下的你的电脑账户文件夹中的.ssh文件夹里的后缀为.pub的文件，右键，以文本文档的方式打开，并赋值里面的内容\n绑定打开GitHub，点击右上角的头像，点击设置(Settings)，点击SSH and GPG keys，在SSH keys一栏的右边有一个New SSH key，点击之后\nTitle：输入名称（随便填）\nKey Type：里面默认即可（Authentication Key）\nKey：里面就填刚复制的内容（要注意回车，最好把光标删除到最后一个字符处）\n完成配置\n试验是否配置成功ssh -T git@github.com\n\n第一次输入命令会让你输入yes，然后回车，只要不报错，就成功了\n","categories":["Git"],"tags":["小知识","SSH"]},{"title":"FastJson","url":"/2023/06/24/java/FastJson/","content":"介绍FastJson是阿里巴巴开源的json解析库，它可以解析json格式的字符串\n具有特点\n速度快\n使用广泛\n测试完备\n使用简单\n功能完备\n\nMaven FatsJson如果是使用的Maven做的项目那么只需要在里面的pom.xml文件里面添加如下代码\n&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.83&lt;/version&gt;&lt;/dependency&gt;\n\n在刷新一下Maven即可\n\n如果添加代码dependency爆红的话只需要在外面加上一层dependencies标签\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;        &lt;version&gt;1.2.83&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n\n\n序列化 —— java对象转json\n[数组]      {对象}\n\nString s = JSON.toJSONString(对象);\n\n传入对象会以字符串形式返回一个json格式的对象\n把java对象转换成json格式的对象\n&#123;\t&quot;键&quot;:值,\t&quot;键&quot;:值,\t&quot;键&quot;:值&#125;\n\n\n\n\nList &lt;泛型&gt; s = new ArrayList&lt;泛型&gt;();  // list集合s.add(对象1);s.add(对象2);String s = JSON.toJSONString(s);\n\n定义一个集合，并传入对象，会以字符串形式返回json格式的数组\n数组中包含对象\n[\t&#123;\t&quot;键&quot;:值,\t&quot;键&quot;:值,\t&quot;键&quot;:值\t&#125;,\t&#123;\t&quot;键&quot;:值,\t&quot;键&quot;:值,\t&quot;键&quot;:值\t&#125;]\n\n\n\n\nMap&lt;键,值&gt; map = new HashMap&lt;键,值&gt;(); // map集合map.put(&quot;键1&quot;,值1);map.put(&quot;键2&quot;,值2);String s = JSON.toJSONString(map);\n\n把map里面的键值对序列化成json的字符串\n&#123;\t&quot;键1&quot;: &#123;\t&quot;键&quot;:值,\t&quot;键&quot;:值,\t&quot;键&quot;:值\t&#125;,\t&quot;键2&quot;: &#123;\t&quot;键&quot;:值,\t&quot;键&quot;:值,\t&quot;键&quot;:值\t&#125;&#125;\n\n反序列化 —— json转Java对象转对象String s = &quot;&#123;&quot;键&quot;:值,&quot;键&quot;:值,&quot;键&quot;:值&#125;&quot;;// JSON类的静态方法\tparseObject// 参数1：需要反序列化的json对象// 参数2：传递Java对象的class对象对象 对象名 = JSON.parseObject(s,对象.class);\n\n转集合String s = [&#123;&quot;键&quot;:值,&quot;键&quot;:值&#125;,&#123;&quot;键&quot;:值,&quot;键&quot;:值,&quot;键&quot;:值&#125;];// JSON类的静态方法\tparseArray// 参数1：json格式字符串// 参数2：转换后的集合的泛型的class对象List&lt;泛型&gt; 集合名 = JSON.parseArray(s,泛型.class);\n\n转MapString s = &#123;&quot;键1&quot;:&#123;&quot;键&quot;:值,&quot;键&quot;:值&#125;,&quot;键2&quot;:&#123;&quot;键&quot;:值,&quot;键&quot;:值,&quot;键&quot;:值&#125;&#125;;// JSON类的静态方法\tparseObject// 直接进行反序列化是没有泛型的（不安全）Map 名 = JSON.parseObject(s);// 调用parseObject，传递参数，TypeReference类型// 在TypeReference类型中传递转后的Map集合// 由于TypeReference类型只能被子类继承所以加&#123;&#125;以匿名内部类Map&lt;键,值&gt; 名 = JSON.parseObjec(s,new TypeReference&lt;Map&lt;键，值&gt;&gt;()&#123;&#125;);\n\n枚举SeriaLizerFeature枚举：进行序列化时，可以自定义特殊需求\njson静态方法\ttoJSONString()\n方法参数1：第一个是要序列化的对象\n方法参数2：第二个SeriaLizerFeature枚举类型的可变参数\n\n// WriteMapNullValue\t枚举中的常量，序列化null值的字段,值序列化为nullString s = JSON.toJSONString(对象,SeriaLizerFeature.WriteMapNullValue);\n\n举例：在对象中如果不给对象赋值的话那么进行toJSONString时不会序列化值为空的对象，但是添加枚举之后没有复制的对象也会显示值为null\n\n// WriteNullStringEmpty\t枚举常量，序列化为null的字段，值序列化为&quot;&quot;String s = JSON.toJSONString(对象,SeriaLizerFeature.WriteNullStringEmpty);\n\n举例：在对象中如果不给对象赋值的话那么进行toJSONString时不会序列化值为空的对象，但是添加枚举之后没有赋值的对象也会显示值为&quot;&quot;\n\n// WriteNullNumberAsZero\t枚举常量，序列化字段值为null的字段，值序列化为0String s = JSON.toJSONString(对象,SeriaLizerFeature.WriteNullNumberAsZero);\n\n举例：在对象中如果不给对象赋值的话那么进行toJSONString时不会序列化值为空的对象，但是添加枚举之后没有赋值的对象也会显示值为0\n\n// WriteNullBooleanFalse 枚举常量,序列化字段值为null的字段，值序列化为falseString s = JSON.toJSONString(对象,SeriaLizerFeature.WriteNullBooleanFalse);\n\n举例：在对象中如果不给对象赋值的话那么进行toJSONString时不会序列化值为空的对象，但是添加枚举之后没有赋值的对象也会显示值为false\n\n// WriteDateUseDateFormat 枚举常量,日期的格式化(前提是得有日期)String s = JSON.toJSONString(对象,SeriaLizerFeature.WriteDateUseDateFormat);\n\n举例：在对象中进行toJSONString时时间是以一堆数字显示,加入这个之后会以日期的方式显示\n\n它可以传入多个枚举常量中间以,分开即可\n\n\n// PrettyFormat 枚举常量,数据格式化String s = JSON.toJSONString(对象,SeriaLizerFeature.PrettyFormat);\n\n举例：在对象中进行toJSONString时数据的格式是以横向显示的\n如:\n&#123;&quot;键1&quot;:&#123;&quot;键&quot;:值,&quot;键&quot;:值&#125;,&quot;键2&quot;:&#123;&quot;键&quot;:值,&quot;键&quot;:值&#125;&#125;\n\n但是经过格式化之后会以这种方式存在\n&#123;    &quot;键1&quot;:&#123;        &quot;键&quot;:值,        &quot;键&quot;:值    &#125;,    &quot;键2&quot;:&#123;        &quot;键&quot;:值,        &quot;键&quot;:值,    &#125;&#125;\n\n注解进行序列化时进行特性定制\n\n注解一定要作用在要序列化的对象上面\n\nJSONFieldJSonField：该注解作用于方法上、字段上、参数上，可在序列化和反序列化时进行特性功能定制\n\nname：序列化后的名字（&#x3D; “名字”）\nordinal：序列化后的顺序（&#x3D; 1 | 2 | 3）\nformat：序列化后的格式（&#x3D; “YYYY - MM - dd”）\nserialize：是否序列化该字段（&#x3D; true | false）\ndeserialize：是否反序列化该字段（&#x3D; true | false）\nserialzeFeatures：序列化时的特性定义（跟枚举差不多）\n\npublic class Student &#123;    private int id;    // @JSONField 注解属性 name ，指定序列化后的名字    @JSONField(name = &quot;sName&quot;)    private String name;    private int age;&#125;\n\n上面注解的意思就是在序列化的时候把原本的name名字改成sName\n\n可以有多个注解中间用,分开\n\nJSONTypeJSONType：该注解作用于类上，对该类的字段进行序列化和反序列化时的特性功能定制\n\nincludes：要被序列化的字段（&#x3D; {“名1” , “名2” , “名3”}）\norders：序列化后的顺序（&#x3D; {“名1” , “名2” , “名3”}）\nserialzeFeatures：序列化时的特性定义（跟枚举差不多）\n\n// 属性：includes 要被序列化的字段@JSONType(includes = &#123;&quot;id&quot;,&quot;name&quot;,&quot;age&quot;&#125;)public class Student &#123;    private int id;    private String name;    private int age;&#125;public class Tests&#123;    public void test()&#123; \t\tStudent s = new Student();\t\ts.setId(1);\t\ts.strName(&quot;张三&quot;);\t\ts.setAge(18);           &#125;&#125;\n\n上面的直接的意思是指定要被序列化的对象的属性，比如上面 id、name、age 都写上了，所以都序列化，但是要是不写 id 那么 id 就不会被序列化 \n上面的JSONField中有一个注解叫 是否序列化该字段 如果给 id 上该注解那么上面没有在JSONType中写 id 的话即使给他上了注解也没用\n@JSONType(includes = &#123;&quot;name&quot;,&quot;age&quot;&#125;)public class Student &#123;    @JSONField(serialize = true)    private int id;    private String name;    private int age;&#125;\n\n","categories":["java"],"tags":["工具","java"]},{"title":"GitHub OAuth","url":"/2024/11/02/java/GitHub%20OAuth/","content":"\n本文将介绍如何基于 OAuth 协议让自己的网络应用集成第三方 GitHub 授权登录\n\n前置内容首先登录（如果没有账号那就注册一个）GitHub\n\n进入设置（Settings）\n点击 Developer Settings\n点击 OAuth Apps\n然后创建应用（New OAuth Apps）\n\n总体流程sequenceDiagram autonumber\n用户->>WEB应用: 使用GitHub登录\nWEB应用->>GitHub: 向GitHub请求权限\nGitHub->>用户: 询问是否同意授权\n用户->>GitHub: 同意授权\nGitHub->>WEB应用: 携带授权码回调地址\nWEB应用->>GitHub: 使用授权码获取access_token\nGitHub->>WEB应用: 校验客户端ID和授权码成功返回access_token\nWEB应用->>GitHub: 携带access_token向GitHub API发送请求\n\n\n\n创建应用\n按照上面表示填写数据信息，尤其是回调地址那一块尤其重要，因为在后续访问时填写参数和回调地址对不上的话会出问题的\n创建客户端ID和密钥\n复制一下客户端ID然后再生成一下看客户点密钥（这个记得保存因为他只明文显示一次）\n代码这里只展示一下最简单的流程信息，代码会非常简陋\n版本情况：\n\nJava:17\nSpringBoot:3.0.5\n\n代码 Demo案例地址：github-login_demo\n配置文件demo:  github:    # 客户端ID    clientId:    # 客户端密钥    clientSecret:    # 回调地址（和GitHub写的回调要保持一致）    redirectUri:\n\n克隆下来上面的代码之后把配置信息填一下然后把代码跑起来\n使用这点里面的代码不涉及任何前端，代码跑起来之后直接在游览器访问：http://localhost:8080。然后后端就会拼接并重定向到请求授权链接，会出现下图\n\n点击绿色的按钮表示同意授权，GitHub就会重定向到之前填写的授权链接并携带上了授权码。像是以下这样：\nhttp://127.0.0.1:8080/redirect?code=1e648753e8051321ca77\n\n此时后端回调地址被调用并接收到 code 码，就会根据 code 码去请求 access_token 令牌。像是以下这样：\naccess_token=a4fdc43gc2fs43cb77v3cd3y27f9cfd6614d29c&amp;scope=&amp;token_type=bearer\n\n然后对这个令牌进行解析，获取到 access_token 后面的字符串，获取到后会携带令牌向 GitHub API 发送请求\n至此大公大功告成！\n","categories":["Java"],"tags":["工具","GitHub","OAuth","第三方登录","SpringBoot","Java","案例","代码"]},{"title":"SpringBoot部署到Tomcat","url":"/2024/10/01/java/SpringBoot%E9%83%A8%E7%BD%B2%E5%88%B0Tomcat/","content":"前言都知道在使用SpringBoot进行部署项目的时候有两种方式。第一种方式就是正常的打成jar包，然后通过 java -jar xxx.jar 命令来运行项目（因为SpringBoot是内嵌的Tomcat服务器的）；第二种方式就是采用老方法让项目打成war包，然后把这个war包放到Tomcat服务器的webapps目录下，最后启动tomcat进行部署。\n这两种方式各有各的好处，首先说说jar包。它呢主要就是方便，不需要再去安装配置tomcat的环境，直接通过命令就能直接运行项目。但是一个项目就需要占用一个端口，不能像直接部署到Tomcat中的那样一个端口中可以运行多个项目。这是因为SpringBoot是内嵌的Tomcat服务器，所以它自己会启动一个Tomcat服务器，用来运行项目。\n再来说说war包，他虽然没有jar包来的方便但是通过部署到tomcat中可以让一个端口中可以运行多个项目。\n在部署的时候不管是jar包还是war包都行，看个人需要。这篇文章就来说说SpringBoot项目如何打成war包并部署到Tomcat中。\n\n版本信息\nSpringBoot:3.1.5\nTomcat:10.1.30\n\n前置继承类SpringBoot项目的启动类需要继承 SpringBootServletInitializer 类，并重写其中的 configure 方法。\nbuilder.sources 方法是用来指定启动类的，里面填写的是启动类的类名。写当前的即可\n@SpringBootApplicationpublic class WPAApplication extends SpringBootServletInitializer &#123;    public static void main(String[] args) &#123;        SpringApplication.run(WPAApplication.class, args);    &#125;    @Override    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123;        return builder.sources(WPAApplication.class);    &#125;&#125;\n\nPOM文件首先在 pom.xml 文件中修改它的打包方式，默认是jar包。修改成war包即可\n&lt;packaging&gt;war&lt;/packaging&gt;\n\n因为SpringBoot是内嵌的Tomcat服务器，所以需要把Tomcat的依赖排除掉\n&lt;!--排除Tomcat--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;\n\n设置包名，在部署到Tomcat后在访问项目中的接口时必须要输入包名\n&lt;!-- 父元素为 build 标签 --&gt;&lt;finalName&gt;项目打包名&lt;finalName&gt;\n\n如果不设置包名那么它的默认包名就是 rtifactId + version 的拼接。\n比如现在有一个项目叫aaa它的版本是0.0.1，在不设置报名的情况下部署到Tomcat中想要访问这个项目需要输入 http://localhost:8080/aaa-0.0.1/接口，但是如果设置包名为 aaa 则访问时输入 http://localhost:8080/aaa/接口 即可。\n部署在打包之前先使用一下 mvn clean 这个命令，清除掉原来 target 目录下的文件。\n然后使用 mvn package 这个命令，开始打包。当出现 BUILD SUCCESS 的时候，说明打包成功。此时 war 包就在 target 目录下了，就是后缀为 .war 的。\n找到war包之后把它上传到服务器中tomcat的webapps目录下。然后启动tomcat不需要解压war包，他会自动进行部署\n","categories":["java"],"tags":["SpringBoot","Java","Spring","服务器","部署","项目部署"]},{"title":"maven安装与配置","url":"/2023/06/21/java/maven%E5%AE%89%E8%A3%85/","content":"Maven是什么Maven是一款服务于Java平台的自动化构建工具。Maven 作为 Java 项目管理工具，它不仅可以用作包管理，还有许多的插件，可以支持整个项目的开发、打包、测试及部署等一系列行为\n因为本来就是使用java写的所以电脑上一定要有jdk这个东西\n不过我想都来下载Maven了应该不会还没有装java吧\nMaven下载和安装去官网上下载\nMaven官网\n往下翻翻到图片中的位置，然后找到图片中红框中的位置点击下载（版本可能不一样）\n\n下载完成之后找个位置解压文件并记下解压的位置\nMaven配置右键此电脑点击属性找到高级系统设置在高级一栏的底下找到环境变量找到系统变量在里面新建\n\n变量名填：MAVEN_HOME\n变量值：填文件解压的位置到bin目录上层位置\n\n意思就是bin目录在这个文件夹里面那么路径到这个文件夹就可以停止了\n\n\n填完之后在系统变量里面找到Path这个名称，双击进入里面\n进入之后点击右边功能区的新建把这个值%MAVEN_HOME%\\bin填入里面这样就算是大功告成了\n\n测试：可以在cmd窗口里面输入mvn -v看看是否输出版本号，正常输出则代表配置成功\n\n修改settings.xml文件\n需要修改三个地方：本地仓库、镜像仓库、JDK\n\n打开文件安装位置在目录里面找到一个叫做conf的文件夹，在文件夹里面有一个文件夹和两个xml文件，找到一个叫做settings.xml的文件，打开它\n配置本地仓库找到图片中的这个位置，并在中间加入以下代码，就跟图片中的一样\n&lt;localRepository&gt;D:\\repository&lt;/localRepository&gt;\n\n盘符和文件夹名称也是可以更改的，具体改成什么样看你自己\n\n配置镜像仓库我们的jar包都是要从互联网仓库去下载的，因为国外的服务器下载jar包很慢所以我们改为阿里云服务器\n复制一下内容在大约160行左右添加如图片所示\n&lt;mirror&gt;    &lt;id&gt;aliyunmaven&lt;/id&gt;    &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;    &lt;name&gt;阿里云公共仓库&lt;/name&gt;    &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt;\n\n\n配置JDK在最后配置jdk，要夹在两个profiles标签之间\n因为我是用的是jdk1.8所以这样写为的就是告诉maven我们用jdk1.8\n&lt;profile&gt;   &lt;id&gt;jdk-1.8&lt;/id&gt;    &lt;activation&gt;\t&lt;activeByDefault&gt;true&lt;/activeByDefault&gt;    &lt;jdk&gt;1.8&lt;/jdk&gt;    &lt;/activation&gt;        &lt;properties&gt;      &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;      &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;      &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;    &lt;/properties&gt;   &lt;/profile&gt;\n\n\n\n测试：在cmd窗口中输入mvn help:system进行尝试，看到下载使用的链接都是阿里的话就代表配置成功了；首次执行 mvn help:system 命令，Maven相关工具自动帮我们到Maven中央仓库下载缺少的或者Maven中央仓库更新的各种配置文件和类库（jar包)到Maven本地仓库中。下载完各种文件后， mvn help:system 命令会打印出所有的Java系统属性和环境变量，这些信息对我们日常的编程工作很有帮助\n\nIDEA配置Maven\n使用版本2022作为演示\n\n一定要从这个地方进行设置这样才能应用到全局，如果你在项目里面进行设置的话那么这个设置仅会在这个项目里面有效，创建新的项目会无法应用这个设置还需要重新设置一边所以要在项目外面进行设置！！！\n\n回归正题，在构建、执行、部署这一栏里面有个构建工具一栏打开它在里面找到Maven，按图所示\n\nIDEA是自带Maven的但是还是要改\n主路径：改成安装的位置bin的上层目录\n用户设置文件：改成上面修改的文件的路径\n本地仓库：这个不用改会自动设置，这里的位置就是前面配置本地仓库的路径\n","categories":["java"],"tags":["工具","java"]},{"title":"使用Java进行json的读取于写入","url":"/2023/06/27/java/%E4%BD%BF%E7%94%A8Java%E8%BF%9B%E8%A1%8Cjson%E7%9A%84%E8%AF%BB%E5%8F%96%E4%BA%8E%E5%86%99%E5%85%A5/","content":"读String readJson(String Cf) &#123;    String json = null;    try &#123;        FileReader f = new FileReader(Cf);        Reader reader = new InputStreamReader(new FileInputStream(Cf));        int ch = 0;        StringBuffer sb = new StringBuffer();        while ((ch = reader.read()) != -1) &#123;            sb.append((char) ch);        &#125;        f.close();        reader.close();        json = sb.toString();    &#125; catch (IOException e) &#123;        System.out.println(&quot;读取信息失败&quot;);    &#125;    return json;&#125;\n\n总体意思就是传入一个字符串，这个值就是你的json文件的路径（可以是相对也可以是绝对），传入之后经过一系列操作最终返回json格式的字符串\n写Map&lt;String, List&lt;泛型&gt;&gt; map = JSON.parseObject(new IOJson().readJson(&quot;文件.json&quot;), new TypeReference&lt;Map&lt;String, List&lt;泛型&gt;&gt;&gt;() &#123;&#125;);for (Map.Entry&lt;String, List&lt;泛型&gt;&gt; entry : map.entrySet()) &#123;    if (entry.getKey().equals(键)) &#123;        entry.getValue().add(值);    &#125;&#125;String json = JSON.toJSONString(map);try &#123;    File upData = new File(文件.json);    upData.createNewFile();    Writer write = new OutputStreamWriter(new FileOutputStream(&quot;文件.json&quot;), &quot;UTF-8&quot;);    write.write(json);    write.flush();    write.close();    System.out.println(&quot;写入成功&quot;);    &#125; catch (IOException e) &#123;    System.out.println(&quot;写入失败&quot;);    &#125;&#125;\n\n这个就是先把json文件给转换成正常的Map集合，然后在使用循环找到自己要找的位置，在这个entry.getValue().add(值)进行增加增加上的集合在进行序列化再次转化成json格式，然后再把全部的字符赋值到文件里面\n这样有一个好处就是增加的数据不会覆盖掉原来的数据，会在原有的基础上增加这就非常的舒服\n","categories":["java"],"tags":["小知识","工具","java","代码"]},{"title":"CentOS7系统安装","url":"/2023/01/30/linux/CentOS7%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/","content":"CentOS 7 简介CentOS 7 操作系统是一款企业级Linux发行版本，是运行在服务器的操作系统\n具体情节：CentOS_百度百科 \nCentOS 7 安装首先得有一个安装系统的环境，或是服务器，或是子系统，或是虚拟机\n今天用的是 VMware Workstation Pro 17 虚拟机安装\n下载VMware直接从官网下载\n官网网址：https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html\n下载链接：https://www.vmware.com/go/getworkstation-win\n下载完之后一直点击下一步，避免安装到系统盘，到输入许可证时输入秘钥\n\n许可证秘钥：JU090-6039P-08409-8J0QH-2YR7F\n\n\n安装完成之后打开软件准备创建CentOS 7系统\n下载 CentOS 7\n虽然CentOS已经有8，但是企业还是以7为主\n\n两种下载方法 镜像站下载，我自己提供的文件下载\n镜像站下载centos-7.9.2009-isos-x86_64安装包下载_开源镜像站-阿里云\n网盘下载CentOS7下载-123云盘下载\nCentOS7下载-百度网盘下载\n安装CentOS 7打开虚拟机，点左上角的创建虚拟机\n\n然后跟着步骤走：\n\n配置选典型然后下一步\n\n安装来源选中间的“安装程序光盘映像文件(iso)”，里面的地址就选你系统文件的下载地址\n\n\n名称和位置随便填，不过位置是要安装的操作系统的位置，所以要预留出足够大的空间\n\n磁盘容量默认20G就行，选第一个“将虚拟磁盘储存为单个文件”，具体看你的使用情况\n\n配置的话默认就行，也可以自己更改\n\n完成创建虚拟机\n\n\n如果打开系统时虚拟机提示“此主机支持AMD-V，但AMD-V处于禁用状态”，那么你需要进入电脑的BIOS更改选项（每个型号的主板进入BIOS的方式都不一样），具体可以自行百度\n开启虚拟机之后有三个选项，选第一个进行安装（通过上下键控制）\n\n等待安装之后进入图形界面，往下滑，点击中文，然后下一步\n\n图形界面中有一些是带感叹号的，那些需要设置一下（其他的也可以自行设置）\n\n\n选完之后点击安装\n\n安装之前要设置一下root密码（作为有着最高权限的账户密码一定要牢记）\n\n安装时间会比较长，耐心等待一下\n安装完成之后点击重启\n\n这样就安装完成了\n","categories":["linux"],"tags":["系统","Linux","CentOS 7"]},{"title":"123云盘API封装","url":"/2024/05/09/%E4%BA%91%E7%9B%98/123%E4%BA%91%E7%9B%98API%E5%B0%81%E8%A3%85/","content":"介绍使用该工具类时需要到123云盘开放平台申请 CLIENT_ID 和 CLIENT_SECRET\n这是对123云盘的所有API链接进行封装，使用时需导入一下Maven坐标吗，主要用于配合解析返回数据\n&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.16.0&lt;/version&gt;&lt;/dependency&gt;\n\n使用时会生成一个配置 config/123pan.json 这里面存放着 Access_Token 和它的过期时间基本上所有的请求都需要携带 Access_Token\nAccess_Token 的获取会在文件加载时进行判断获取，也可以使用 OneTwoThreeCloudDisk.getAccessToken() 进行手动获取，每次请求API时会先判断 Access_Token 是否可用\n请求如果请求失败会有三次重试机会，可以更改 RETRY_MAX 改变次数\nAPI介绍所有的API都有些注释（这个API干什么用的以及需要什么参数），到时候按照要求来，返回值请参考官方文档，所有接口统一返回 Map\n常量介绍CLIENT_ID：申请到的客户端ID\nCLIENT_SECRET：申请到的客户端密钥\nRETRY_MAX：请求出错后的重试次数\nPRIVATE_KEY：URL鉴权处所设置的鉴权密钥\nUID：本用户的ID\nEXPIRED_TIME_SEC：防盗链过期的时间(秒) \nJSON_FILE：这里设置JSON文件的地址里面存放着ACCESS_TOKEN和过期时间\nAPI：请求API的根域名\n自定义API测算文件的大小和MD5工具API：fileSizeAndMD5()\n对文件进行分片工具API：splitFile()\n分片的时候会创建一个 part 的文件夹，里面存放着分片信息，路径格式为：part/文件名/文件名-num.part\n上传分片文件工具API：uploadShardsPUT()\n一条龙上传文件工具API：uploadFile()\n只需要提供要上传文件的路径、文件名（带后缀）、目录ID即可自动完成所有操作，上传完成之后会删除所有分片\n返回信息（Map）：\n\n如果 code 码为0则说明完成请求\n如果 code 码为1则说明上传分片时上传失败，返回 errorNum（上传失败的分片数）、countNum（全部分片数量）、preuploadID（预上传ID）\n如果 code 码为2则说明查询上传结果重试了60次还是没有合并成功\n\n一条龙上传文件 - 返回直链工具API：uploadFileAndGetDirectLink()\n介绍：包含一条龙上传文件并且上传完成之后返回直链信息\n要求：需要上传的目录必须是直链空间\nURL鉴权 - 防盗链工具API：URLAuthentication()\n介绍：在云盘内开启URL鉴权之后所访问呢的链接就需要进行加密校验了，只需要把直链链接传入即可返回加密链接\n注意：需要在常量中添加相对应的数据\n一条龙上传文件 - 返回直链+防盗链工具API：uploadFilesAndGetAuthenticationLink()\n介绍：包含一条龙上传文件并且上传完成之后返回直链信息\n要求：需要上传的目录必须是直链空间，需要在常量中添加相对应的数据\n散装 API获取用户信息官方文档：获取用户信息 (yuque.com)\n工具API：getUserInfo()\n创建离线下载任务官方文档：创建离线下载任务 (yuque.com)\n工具API：createOfflineDownloadTask()\n获取离线下载进度官方文档：获取离线下载进度 (yuque.com)\n工具API：getProgressYourOfflineDownload()\n创建分享链接官方文档：创建分享链接 (yuque.com)\n工具API：createSharedLink()\n获取access_token官方文档：获取access_token (yuque.com)\n工具API：OneTwoThreeCloudDisk.getAccessToken()\n直链\n所有直链相关的API以 straight 开头\n\n获取直链链接官方文档：获取直链链接 (yuque.com)\n工具API：straight_GetADirectLink()\n启用直链空间官方文档：启用直链空间 (yuque.com)\n工具API：straight_EnableDirectLinkSpace()\n禁用直链空间官方文档：禁用直链空间 (yuque.com)\n工具API：straight_DisableDirectLinkSpace()\n获取直链转码链接官方文档：获取直链转码链接 (yuque.com)\n工具API：straight_GetDirectLinkTranscode()\n发起直链转码官方文档：发起直链转码 (yuque.com)\n工具API：straight_InitiateDirectChainTranscode()\n查询直链转码进度官方文档：查询直链转码进度 (yuque.com)\n工具API：straight_QueryTranscodingProgress()\n文件管理\n所有文件管理的API以 file 开头\n\n获取文件列表官方文档：获取文件列表 (yuque.com)\n工具API：file_GetListOfFiles()\n文件重命名官方文档：文件重命名 (yuque.com)\n工具API：file_heavyNaming()\n从回收站恢复文件官方文档：从回收站恢复文件 (yuque.com)\n工具API：file_RecoverFilesFromRecycleBin()\n删除文件至回收站官方文档：删除文件至回收站 (yuque.com)\n工具API：file_DeleteFilesToRecycleBin()\n彻底删除文件官方文档：彻底删除文件 (yuque.com)\n工具API：file_DeleteFilesCompletely()\n移动文件官方文档：移动文件 (yuque.com)\n工具API：file_MoveFiles()\n上传文件上传流程：上传流程 (yuque.com)\n上传文件 - 创建目录官方文档：创建目录 (yuque.com)\n工具API：file_CreateCatalog()\n上传文件 - 创建文件官方文档：创建文件 (yuque.com)\n工具API：file_CreateFile()\n上传文件 - 列举已上传分片官方文档：列举已上传分片 (yuque.com)\n工具API：file_ListUploadedParts()\n上传文件 - 获取上传地址官方文档：获取上传地址 (yuque.com)\n工具API：file_ObtainUploadURL()\n上传文件 - 上传完毕官方文档：上传完毕 (yuque.com)\n工具API：file_UploadCompleted()\n上传文件 - 异步轮询获取上传结果官方文档：异步轮询获取上传结果 (yuque.com)\n工具API：file_AsyncPollToObtainUploadResults()\n代码import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import java.io.*;import java.math.BigInteger;import java.net.*;import java.net.http.HttpClient;import java.net.http.HttpRequest;import java.net.http.HttpResponse;import java.nio.charset.StandardCharsets;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.time.Duration;import java.time.ZonedDateTime;import java.util.*;/** * @version 1.5 * @description: 123云盘开放API封装 * @author: 曦暮流年 * @see &lt;a href=&quot;https://blog.ximuliunian.top/2024/05/09/云盘/123云盘API封装/&quot;&gt;API文档详情&lt;/a&gt; */public class OneTwoThreeCloudPan &#123;    // 客户端ID    private static final String CLIENT_ID = &quot;&quot;;    // 客户端密钥    private static final String CLIENT_SECRET = &quot;&quot;;    // 请求出错后的重试次数    private static final int RETRY_MAX = 3;    // 密钥 - URL鉴权    private static final String PRIVATE_KEY = &quot;&quot;;    // 用户UID - URL鉴权    private static final long UID = ;    // 防盗链过期时间(秒) - URL鉴权    private static final long EXPIRED_TIME_SEC = 3 * 60;    // 123云盘 JSON文件    private static String JSON_FILE = &quot;config/123pan.json&quot;;    // 请求API    private static final String API = &quot;https://open-api.123pan.com&quot;;    // 请求令牌    private static String ACCESS_TOKEN;    // 令牌过期时间    private static String EXPIRED_AT;    // 创建客户端    private static final HttpClient client = HttpClient.newHttpClient();    // JSON解析    private static final ObjectMapper mapper = new ObjectMapper();    // 初始化配置文件    static &#123;        File file = new File(JSON_FILE);        // 获取父目录        File parentDir = file.getParentFile();        // 如果父目录不存在，则创建        if (!parentDir.exists()) &#123;            if (parentDir.mkdirs()) System.out.println(&quot;父目录创建成功&quot;);            else System.out.println(&quot;父目录创建失败&quot;);        &#125;        // 如果文件不存在，则创建文件        if (!file.exists()) &#123;            try &#123;                if (file.createNewFile()) &#123;                    System.out.println(&quot;初始化123云盘配置成功&quot;);                    System.out.println(&quot;开始获取AccessToken&quot;);                    getAccessToken();                    System.out.println(&quot;获取AccessToken成功&quot;);                &#125; else throw new RuntimeException(&quot;初始化123云盘配置失败&quot;);            &#125; catch (IOException e) &#123;                throw new RuntimeException(&quot;初始化123云盘配置失败&quot;);            &#125;        &#125; else &#123;            // 读取文件并给常量赋值            try &#123;                ACCESS_TOKEN = mapper.readTree(file).get(&quot;data&quot;).get(&quot;accessToken&quot;).asText();                EXPIRED_AT = mapper.readTree(file).get(&quot;data&quot;).get(&quot;expiredAt&quot;).asText();            &#125; catch (IOException e) &#123;                // 获取失败大概率是因为文件为空，重新发送请求获取内容                getAccessToken();            &#125;        &#125;    &#125;    /**     * 获取access_token     *     * @see &lt;a href=&quot;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/gn1nai4x0v0ry9ki&quot;&gt;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/gn1nai4x0v0ry9ki&lt;/a&gt;     */    public static Map&lt;String, Object&gt; getAccessToken() &#123;        try &#123;            // 请求体            String body = mapper.writeValueAsString(Map.of(                    &quot;clientID&quot;, CLIENT_ID,                    &quot;clientSecret&quot;, CLIENT_SECRET            ));            // 创建请求            HttpRequest request = HttpRequest.newBuilder()                    .header(&quot;platform&quot;, &quot;open_platform&quot;)                    .uri(new URI(API + &quot;/api/v1/access_token&quot;))                    .POST(HttpRequest.BodyPublishers.ofString(body, StandardCharsets.UTF_8))                    .build();            // 验证当前时间是否与过期时间相隔太大            ZonedDateTime givenTime = EXPIRED_AT == null ? ZonedDateTime.now() : ZonedDateTime.parse(EXPIRED_AT);            ZonedDateTime currentTime = ZonedDateTime.now();            Duration duration = Duration.between(currentTime, givenTime);            // 如果相隔时间小于3天或者令牌过期或者过期时间为空，则发送请求            if (duration.toDays() &lt; 3 || !givenTime.isAfter(currentTime) || EXPIRED_AT.isBlank()) &#123;                // 发送请求                HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());                // 获取返回响应并更新到JSON文件中                Map&lt;String, Object&gt; map = mapper.readValue(response.body(), Map.class);                mapper.writeValue(new File(JSON_FILE), map);                // 校验Code                Integer code = (Integer) map.get(&quot;code&quot;);                if (code == 0) System.out.println(&quot;请求成功&quot;);                else if (code == 401) throw new RuntimeException(&quot;access_token无效&quot;);                else if (code == 429) throw new RuntimeException(&quot;请求太频繁&quot;);                else throw new RuntimeException(&quot;异常 - 状态码：&quot; + code + &quot;；原因：&quot; + map.get(&quot;message&quot;));                // 更新常量                Map&lt;String, Object&gt; data = (Map&lt;String, Object&gt;) map.get(&quot;data&quot;);                ACCESS_TOKEN = (String) data.get(&quot;accessToken&quot;);                EXPIRED_AT = (String) data.get(&quot;expiredAt&quot;);                return map;            &#125; else throw new RuntimeException(&quot;令牌过期距离过期时间过长&quot;);        &#125; catch (URISyntaxException e) &#123;            throw new RuntimeException(&quot;创建请求失败&quot;);        &#125; catch (JsonProcessingException e) &#123;            throw new RuntimeException(&quot;创建请求体失败&quot;);        &#125; catch (IOException | InterruptedException e) &#123;            throw new RuntimeException(&quot;发送请求失败&quot;);        &#125;    &#125;    /**     * 构建POST请求     *     * @param url  请求路径，带/     * @param body 请求体     * @return HttpRequest     */    private HttpResponse&lt;String&gt; buildRequestPOST(String url, Map&lt;String, Object&gt; body) &#123;        // 验证当前时间是否与过期时间相隔太大        ZonedDateTime givenTime = ZonedDateTime.parse(EXPIRED_AT);        ZonedDateTime currentTime = ZonedDateTime.now();        Duration duration = Duration.between(currentTime, givenTime);        // 如果令牌时间少于三天或者令牌过期则重新获取        if (duration.toDays() &lt; 3 || !givenTime.isAfter(currentTime)) getAccessToken();        // 创建请求        HttpRequest.Builder builder = HttpRequest.newBuilder();        builder.header(&quot;Authorization&quot;, &quot;Bearer &quot; + ACCESS_TOKEN);        builder.header(&quot;Platform&quot;, &quot;open_platform&quot;);        builder.header(&quot;Content-Type&quot;, &quot;application/json&quot;);        int retry = 0;        while (true) &#123;            try &#123;                builder.POST(HttpRequest.BodyPublishers.ofString(mapper.writeValueAsString(body), StandardCharsets.UTF_8));                builder.uri(new URI(API + url));                return client.send(builder.build(), HttpResponse.BodyHandlers.ofString());            &#125; catch (JsonProcessingException e) &#123;                throw new RuntimeException(&quot;创建请求体失败&quot;);            &#125; catch (URISyntaxException e) &#123;                throw new RuntimeException(&quot;创建请求地址失败&quot;);            &#125; catch (IOException | InterruptedException e) &#123;                if (retry &gt;= RETRY_MAX) throw new RuntimeException(&quot;发送POST请求失败&quot;);                System.out.println(&quot;发送POST请求失败，重试中...&quot;);                retry++;            &#125;        &#125;    &#125;    /**     * 构建GET请求     *     * @param url         请求路径，开头带/     * @param queryString GET请求地址参数，无则填null     * @return HttpRequest     */    private HttpResponse&lt;String&gt; buildRequestGET(String url, Map&lt;String, Object&gt; queryString) &#123;        // 验证当前时间是否与过期时间相隔太大        ZonedDateTime givenTime = ZonedDateTime.parse(EXPIRED_AT);        ZonedDateTime currentTime = ZonedDateTime.now();        Duration duration = Duration.between(currentTime, givenTime);        // 如果令牌时间少于三天或者令牌过期则重新获取        if (duration.toDays() &lt; 3 || !givenTime.isAfter(currentTime)) getAccessToken();        // 创建请求        HttpRequest.Builder builder = HttpRequest.newBuilder();        builder.header(&quot;Authorization&quot;, &quot;Bearer &quot; + ACCESS_TOKEN);        builder.header(&quot;Platform&quot;, &quot;open_platform&quot;);        builder.GET();        // 拼接参数        StringBuilder sb = new StringBuilder();        if (queryString != null)            queryString.forEach((k, v) -&gt; sb.append(k).append(&quot;=&quot;).append(v).append(&quot;&amp;&quot;));        int retry = 0;        // 请求重试        while (true) &#123;            try &#123;                URI uri = new URI(API + url + &quot;?&quot; + sb.toString());                builder.uri(uri);                return client.send(builder.build(), HttpResponse.BodyHandlers.ofString());            &#125; catch (URISyntaxException e) &#123;                throw new RuntimeException(&quot;创建请求地址失败&quot;);            &#125; catch (IOException | InterruptedException e) &#123;                if (retry &gt;= RETRY_MAX) throw new RuntimeException(&quot;发送GET请求失败&quot;);                System.out.println(&quot;发送GET请求失败，重试中......&quot;);                retry++;            &#125;        &#125;    &#125;    /**     * 校验 Code 是否正确     *     * @param code 状态码     */    private void codeVerify(int code, String msg) &#123;        switch (code) &#123;            case 0 -&gt; System.out.println(&quot;请求成功&quot;);            case 401 -&gt; throw new RuntimeException(&quot;access_token无效&quot;);            case 429 -&gt; throw new RuntimeException(&quot;请求太频繁&quot;);            default -&gt; throw new RuntimeException(&quot;异常 - 状态码：&quot; + code + &quot;；原因：&quot; + msg);        &#125;    &#125;    /**     * 响应内容处理     *     * @param response 响应内容     * @param msg      属于什么方法     * @return Map     */    private Map&lt;String, Object&gt; responseProcess(HttpResponse&lt;String&gt; response, String msg) &#123;        try &#123;            Map&lt;String, Object&gt; map = mapper.readValue(response.body(), Map.class);            codeVerify((Integer) map.get(&quot;code&quot;), (String) map.get(&quot;message&quot;));            return (Map&lt;String, Object&gt;) map.get(&quot;data&quot;);        &#125; catch (JsonProcessingException e) &#123;            throw new RuntimeException(msg + &quot; - JSON解析失败\\n\\t返回内容：&quot; + response.body());        &#125;    &#125;    /**     * 获取用户信息     *     * @see &lt;a href=&quot;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/fa2w0rosunui2v4m&quot;&gt;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/fa2w0rosunui2v4m&lt;/a&gt;     */    public Map&lt;String, Object&gt; getUserInfo() &#123;        System.out.println(&quot;请求用户信息......&quot;);        HttpResponse&lt;String&gt; send = buildRequestGET(&quot;/api/v1/user/info&quot;, null);        return responseProcess(send, &quot;获取用户信息&quot;);    &#125;    /**     * 创建离线下载任务&lt;br/&gt;     * 离线下载任务仅支持 http/https 任务创建     *     * @param url         下载资源地址(http/https) - 必填     * @param fileName    自定义文件名称（带后缀）无则填null - 非必填     * @param dirID       目录ID - 非必填     * @param callBackUrl 回调地址，无则填null - 非必填     * @see &lt;a href=&quot;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/wn77piehmp9t8ut4&quot;&gt;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/wn77piehmp9t8ut4&lt;/a&gt;     */    public Map&lt;String, Object&gt; createOfflineDownloadTask(String url, String fileName, String dirID, String callBackUrl) &#123;        System.out.println(&quot;请求创建离线下载任务......&quot;);        Map&lt;String, Object&gt; body = new HashMap&lt;&gt;();        body.put(&quot;url&quot;, url);        body.put(&quot;fileName&quot;, fileName == null ? &quot;&quot; : fileName);        body.put(&quot;dirID&quot;, dirID == null ? &quot;&quot; : dirID);        body.put(&quot;callBackUrl&quot;, callBackUrl == null ? &quot;&quot; : callBackUrl);        HttpResponse&lt;String&gt; response = buildRequestPOST(&quot;/api/v1/offline/download&quot;, body);        return responseProcess(response, &quot;创建离线下载任务&quot;);    &#125;    /**     * 获取离线下载进度     *     * @param taskID 离线下载任务ID     * @see &lt;a href=&quot;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/dvxrtr9gfyk2lvlu&quot;&gt;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/dvxrtr9gfyk2lvlu&lt;/a&gt;     */    public Map&lt;String, Object&gt; getProgressYourOfflineDownload(int taskID) &#123;        System.out.println(&quot;请求获取离线下载进度......&quot;);        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;taskID&quot;, taskID);        HttpResponse&lt;String&gt; response = buildRequestGET(&quot;/api/v1/offline/download/process&quot;, map);        return responseProcess(response, &quot;获取离线下载进度&quot;);    &#125;    /**     * 分享链接有效期     * &lt;br/&gt;     * ONE_DAY - 1天&lt;br/&gt;     * SEVEN_DAYS - 7天&lt;br/&gt;     * THIRTY_DAYS - 30天&lt;br/&gt;     * PERMANENT - 永久     */    public enum ShareExpire &#123;        ONE_DAY(1),        SEVEN_DAYS(7),        THIRTY_DAYS(30),        PERMANENT(0);        private final int days;        ShareExpire(int days) &#123;            this.days = days;        &#125;        public int getDays() &#123;            return days;        &#125;    &#125;    /**     * 创建分享链接     *     * @param shareName   分享名称 - 必填     * @param shareExpire 分享链接有效期天数 - 必填     * @param fileIDList  分享文件ID列表,以逗号分割,最大只支持拼接100个文件ID,示例:1,2,3 - 必填     * @param sharePwd    分享密码，无则填null - 选填     * @see &lt;a href=&quot;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/dwd2ss0qnpab5i5s&quot;&gt;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/dwd2ss0qnpab5i5s&lt;/a&gt;     */    public Map&lt;String, Object&gt; createSharedLink(String shareName, ShareExpire shareExpire, String fileIDList, String sharePwd) &#123;        System.out.println(&quot;请求创建分享链接......&quot;);        Map&lt;String, Object&gt; body = new HashMap&lt;&gt;();        body.put(&quot;shareName&quot;, shareName);        body.put(&quot;shareExpire&quot;, shareExpire.getDays());        body.put(&quot;fileIDList&quot;, fileIDList);        body.put(&quot;sharePwd&quot;, sharePwd == null ? &quot;&quot; : sharePwd);        HttpResponse&lt;String&gt; response = buildRequestPOST(&quot;/api/v1/share/create&quot;, body);        return responseProcess(response, &quot;创建分享链接&quot;);    &#125;    /**     * 排序规则     * &lt;br/&gt;     * FILE_ID - 文件ID&lt;br/&gt;     * SIZE - 文件大小&lt;br/&gt;     * FILE_NAME - 文件名     */    public enum OrderBy &#123;        FILE_ID(&quot;file_id&quot;),        SIZE(&quot;size&quot;),        FILE_NAME(&quot;file_name&quot;);        private final String value;        OrderBy(String fileName) &#123;            this.value = fileName;        &#125;        public String getValue() &#123;            return value;        &#125;    &#125;    /**     * 获取文件列表     *     * @param parentFileId   文件夹ID，根目录传0 - 必填     * @param page           页码数 - 必填     * @param limit          每页条数，最大不超过100 - 必填     * @param orderBy        排序字段 - 必填     * @param orderDirection 排序方向，1为升序，0为降序 - 必填     * @param trashed        是否查看回收站的文件 - 必填     * @param searchData     搜索关键字，无则填null - 选填     * @see &lt;a href=&quot;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/hosdqqax0knovnm2&quot;&gt;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/hosdqqax0knovnm2&lt;/a&gt;     */    public Map&lt;String, Object&gt; file_GetListOfFiles(int parentFileId, int page, int limit, OrderBy orderBy, int orderDirection, boolean trashed, String searchData) &#123;        System.out.println(&quot;请求获取文件列表......&quot;);        Map&lt;String, Object&gt; body = new HashMap&lt;&gt;();        body.put(&quot;parentFileId&quot;, parentFileId);        body.put(&quot;page&quot;, page);        body.put(&quot;limit&quot;, Math.min(limit, 100));        body.put(&quot;orderBy&quot;, orderBy.getValue());        body.put(&quot;orderDirection&quot;, orderDirection == 1 ? &quot;asc&quot; : &quot;desc&quot;);        body.put(&quot;trashed&quot;, trashed);        body.put(&quot;searchData&quot;, searchData == null ? &quot;&quot; : searchData);        HttpResponse&lt;String&gt; response = buildRequestGET(&quot;/api/v1/file/list&quot;, body);        return responseProcess(response, &quot;获取文件列表&quot;);    &#125;    /**     * 移动文件&lt;br/&gt;     * 批量移动文件，单级最多支持100个     *     * @param fileIDs        文件id数组 - 必填     * @param toParentFileID 要移动到的目标文件夹id，移动到根目录时填写0 - 必填     * @see &lt;a href=&quot;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/rsyfsn1gnpgo4m4f&quot;&gt;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/rsyfsn1gnpgo4m4f&lt;/a&gt;     */    public Map&lt;String, Object&gt; file_MoveFiles(List&lt;String&gt; fileIDs, String toParentFileID) &#123;        System.out.println(&quot;请求移动文件......&quot;);        Map&lt;String, Object&gt; body = new HashMap&lt;&gt;();        body.put(&quot;fileIDs&quot;, fileIDs);        body.put(&quot;toParentFileID&quot;, toParentFileID);        HttpResponse&lt;String&gt; response = buildRequestPOST(&quot;/api/v1/file/move&quot;, body);        return responseProcess(response, &quot;移动文件&quot;);    &#125;    /**     * 删除文件至回收站&lt;br/&gt;     * 删除的文件，会放入回收站中     *     * @param fileIDs 文件id数组,一次性最大不能超过100 个文件 - 必填     * @see &lt;a href=&quot;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/en07662k2kki4bo6&quot;&gt;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/en07662k2kki4bo6&lt;/a&gt;     */    public Map&lt;String, Object&gt; file_DeleteFilesToRecycleBin(List&lt;String&gt; fileIDs) &#123;        System.out.println(&quot;请求删除文件至回收站......&quot;);        Map&lt;String, Object&gt; body = new HashMap&lt;&gt;();        body.put(&quot;fileIDs&quot;, fileIDs);        HttpResponse&lt;String&gt; response = buildRequestPOST(&quot;/api/v1/file/trash&quot;, body);        return responseProcess(response, &quot;删除文件至回收站&quot;);    &#125;    /**     * 文件重命名&lt;br/&gt;     * 说明：批量重命名文件，最多支持同时30个文件重命名&lt;br/&gt;     * 每个成员的格式为：文件ID|新的文件名&lt;br/&gt;     * 示例：&quot;114514|新的文件名&quot;     *     * @param names 重命名列表     * @see &lt;a href=&quot;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/ec18ovepgciazfuc&quot;&gt;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/ec18ovepgciazfuc&lt;/a&gt;     */    public Map&lt;String, Object&gt; file_heavyNaming(List&lt;String&gt; names) &#123;        System.out.println(&quot;请求文件重命名......&quot;);        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;renameList&quot;, names);        HttpResponse&lt;String&gt; send = buildRequestPOST(&quot;/api/v1/file/rename&quot;, map);        return responseProcess(send, &quot;文件重命名&quot;);    &#125;    /**     * 从回收站恢复文件&lt;br/&gt;     * 将回收站的文件恢复至删除前的位置     *     * @param fileIDs 文件id数组,一次性最大不能超过100 个文件 - 必填     * @see &lt;a href=&quot;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/kx9f8b6wk6g55uwy&quot;&gt;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/kx9f8b6wk6g55uwy&lt;/a&gt;     */    public Map&lt;String, Object&gt; file_RecoverFilesFromRecycleBin(List&lt;String&gt; fileIDs) &#123;        System.out.println(&quot;请求从回收站恢复文件......&quot;);        Map&lt;String, Object&gt; body = new HashMap&lt;&gt;();        body.put(&quot;fileIDs&quot;, fileIDs);        HttpResponse&lt;String&gt; response = buildRequestPOST(&quot;/api/v1/file/recover&quot;, body);        return responseProcess(response, &quot;从回收站恢复文件&quot;);    &#125;    /**     * 彻底删除文件&lt;br/&gt;     * 彻底删除文件前,文件必须要在回收站中,否则无法删除     *     * @param fileIDs 文件id数组,参数长度最大不超过100 - 必填     * @see &lt;a href=&quot;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/sg2gvfk5i3dwoxtg&quot;&gt;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/sg2gvfk5i3dwoxtg&lt;/a&gt;     */    public Map&lt;String, Object&gt; file_DeleteFilesCompletely(List&lt;String&gt; fileIDs) &#123;        System.out.println(&quot;请求彻底删除文件......&quot;);        Map&lt;String, Object&gt; body = new HashMap&lt;&gt;();        body.put(&quot;fileIDs&quot;, fileIDs);        HttpResponse&lt;String&gt; response = buildRequestPOST(&quot;/api/v1/file/delete&quot;, body);        return responseProcess(response, &quot;彻底删除文件&quot;);    &#125;    /**     * 创建目录     *     * @param name     目录名(注:不能重名) - 必填     * @param parentID 父目录id，上传到根目录时填写0 - 必填     * @see &lt;a href=&quot;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/gvz09ibuuo97i5ue&quot;&gt;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/gvz09ibuuo97i5ue&lt;/a&gt;     */    public Map&lt;String, Object&gt; file_CreateCatalog(String name, int parentID) &#123;        System.out.println(&quot;请求创建目录......&quot;);        Map&lt;String, Object&gt; body = new HashMap&lt;&gt;();        body.put(&quot;name&quot;, name);        body.put(&quot;parentID&quot;, parentID);        HttpResponse&lt;String&gt; response = buildRequestPOST(&quot;/upload/v1/file/mkdir&quot;, body);        return responseProcess(response, &quot;创建目录&quot;);    &#125;    /**     * 根据文件的路径算出文件的大小和MD5值     *     * @param filePath 文件路径     * @return Map（&quot;size&quot;:文件大小,&quot;md5&quot;:文件md5）     */    public Map&lt;String, Object&gt; fileSizeAndMD5(String filePath) &#123;        System.out.println(&quot;测算 &quot; + filePath + &quot; 文件大小与MD5......&quot;);        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        try &#123;            File file = new File(filePath);            MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);            FileInputStream fis = new FileInputStream(file);            byte[] buffer = new byte[1024];            int length;            while ((length = fis.read(buffer)) != -1) &#123;                md5.update(buffer, 0, length);            &#125;            fis.close();            byte[] digest = md5.digest();            BigInteger bigInt = new BigInteger(1, digest);            map.put(&quot;md5&quot;, bigInt.toString(16));            map.put(&quot;size&quot;, file.length());            return map;        &#125; catch (NoSuchAlgorithmException | IOException e) &#123;            throw new RuntimeException(&quot;测算文件大小与MD5异常 - &quot; + e.getMessage());        &#125;    &#125;    /**     * 对文件进行分片&lt;br/&gt;     * 分片的文件保存路径为 part/&#123;文件名&#125;/&#123;文件名&#125;-&#123;分片序号&#125;.part     *     * @param filePath 被分片的文件     * @param partSize 分片大小     * @return Map（&quot;num&quot;:分片数,&quot;path&quot;:保存路径,&quot;fileName&quot;:文件名）     */    public Map&lt;String, Object&gt; splitFile(String filePath, int partSize) &#123;        System.out.println(&quot;分片中......&quot;);        File file = new File(filePath);        int numParts = (int) Math.ceil((double) file.length() / partSize);        Map&lt;String, Object&gt; partInfo = new HashMap&lt;&gt;();        try (FileInputStream fis = new FileInputStream(file)) &#123;            // 如果文件夹不存在则创建            File dir = new File(String.format(&quot;part/%s&quot;, file.getName()));            if (!dir.exists()) dir.mkdirs();            partInfo.put(&quot;fileName&quot;, file.getName() + &quot;-&quot;);            partInfo.put(&quot;path&quot;, String.format(&quot;part/%s&quot;, file.getName()));            // 分片            for (int i = 1; i &lt;= numParts; i++) &#123;                // 分片文件名                String partFileName = String.format(&quot;part/%s/%s-%d.part&quot;, file.getName(), file.getName(), i);                try (FileOutputStream fos = new FileOutputStream(partFileName)) &#123;                    byte[] buffer = new byte[partSize];                    int bytesRead = fis.read(buffer);                    fos.write(buffer, 0, bytesRead);                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        partInfo.put(&quot;num&quot;, numParts);        System.out.println(&quot;分片完成&quot;);        return partInfo;    &#125;    /**     * 创建文件     *     * @param parentFileID 父目录id，上传到根目录时填写0 - 必填     * @param filename     文件名要小于128个字符且不能包含以下任何字符：&quot;\\/:*?|&gt;&lt;（注：不能重名，带后缀） - 必填     * @param etag         文件md5 - 必填     * @param size         文件大小，单位为 byte 字节 - 必填     * @see &lt;a href=&quot;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/tutyp6gd8m20z0nz&quot;&gt;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/tutyp6gd8m20z0nz&lt;/a&gt;     */    public Map&lt;String, Object&gt; file_CreateFile(int parentFileID, String filename, String etag, Number size) &#123;        System.out.println(&quot;请求创建文件......&quot;);        Map&lt;String, Object&gt; body = new HashMap&lt;&gt;();        body.put(&quot;parentFileID&quot;, parentFileID);        body.put(&quot;filename&quot;, filename);        body.put(&quot;etag&quot;, etag);        body.put(&quot;size&quot;, size);        HttpResponse&lt;String&gt; response = buildRequestPOST(&quot;/upload/v1/file/create&quot;, body);        return responseProcess(response, &quot;创建文件&quot;);    &#125;    /**     * 获取上传地址     *     * @param preuploadID 预上传ID - 必填     * @param sliceNo     分片序号，从1开始自增 - 必填     * @see &lt;a href=&quot;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/tefyp5usugp3lnsr&quot;&gt;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/tefyp5usugp3lnsr&lt;/a&gt;     */    public Map&lt;String, Object&gt; file_ObtainUploadURL(String preuploadID, int sliceNo) &#123;        System.out.println(&quot;请求获取上传地址......&quot;);        Map&lt;String, Object&gt; body = new HashMap&lt;&gt;();        body.put(&quot;preuploadID&quot;, preuploadID);        body.put(&quot;sliceNo&quot;, sliceNo);        HttpResponse&lt;String&gt; response = buildRequestPOST(&quot;/upload/v1/file/get_upload_url&quot;, body);        return responseProcess(response, &quot;获取上传地址&quot;);    &#125;    /**     * 上传分片文件     *     * @param path      分片文件路径     * @param serverUrl 上传地址     * @return true上传成功 false上传失败     */    public boolean uploadShardsPUT(String path, String serverUrl) &#123;        System.out.println(&quot;分片文件 &quot; + path + &quot; 上传中......&quot;);        int retry = 0;        while (true) &#123;            try &#123;                // 初始化数据                File file = new File(path);                URL url = new URL(serverUrl);                HttpURLConnection connection = (HttpURLConnection) url.openConnection();                connection.setRequestMethod(&quot;PUT&quot;);                connection.setDoOutput(true);                connection.setRequestProperty(&quot;Content-Type&quot;, &quot;application/octet-stream&quot;);                connection.setRequestProperty(&quot;Content-Length&quot;, String.valueOf(file.length()));                // 上传                OutputStream outputStream = connection.getOutputStream();                FileInputStream fileInputStream = new FileInputStream(file);                byte[] buffer = new byte[4096];                int bytesRead;                while ((bytesRead = fileInputStream.read(buffer)) != -1) &#123;                    outputStream.write(buffer, 0, bytesRead);                &#125;                // 上传完成                outputStream.flush();                outputStream.close();                fileInputStream.close();                // 获取响应                int responseCode = connection.getResponseCode();                if (responseCode == HttpURLConnection.HTTP_OK) &#123;                    System.out.println(&quot;文件：&quot; + path + &quot; 上传成功&quot;);                    return true;                &#125; else &#123;                    if (retry &gt;= RETRY_MAX) &#123;                        System.out.println(&quot;上传分片文件失败&quot;);                        return false;                    &#125;                    System.out.println(&quot;文件：&quot; + path + &quot; 上传失败，错误码：&quot; + responseCode + &quot;错误响应：&quot; + connection.getResponseMessage());                    System.out.println(&quot;重试上传文件：&quot; + path);                    retry++;                &#125;            &#125; catch (IOException e) &#123;                if (retry &gt;= RETRY_MAX) &#123;                    System.out.println(&quot;上传分片文件失败&quot;);                    return false;                &#125;                System.out.println(&quot;文件：&quot; + path + &quot; 上传失败，错误信息：&quot; + e.getMessage());                System.out.println(&quot;重试上传文件：&quot; + path);                retry++;            &#125;        &#125;    &#125;    /**     * 列举已上传分片&lt;br/&gt;     * 该接口用于最后一片分片上传完成时,列出云端分片供用户自行比对。比对正确后调用上传完毕接口&lt;br/&gt;     * 当文件大小小于 sliceSize 分片大小时,无需调用该接口。该结果将返回空值。     *     * @param preuploadID 预备上传ID - 必填     * @see &lt;a href=&quot;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/vfciz4tmloogx6b6&quot;&gt;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/vfciz4tmloogx6b6&lt;/a&gt;     */    public Map&lt;String, Object&gt; file_ListUploadedParts(String preuploadID) &#123;        System.out.println(&quot;请求列举已上传分片......&quot;);        Map&lt;String, Object&gt; body = new HashMap&lt;&gt;();        body.put(&quot;preuploadID&quot;, preuploadID);        HttpResponse&lt;String&gt; response = buildRequestPOST(&quot;/upload/v1/file/list_upload_parts&quot;, body);        return responseProcess(response, &quot;列举已上传分片&quot;);    &#125;    /**     * 上传完毕&lt;br/&gt;     * 文件上传完成后请求     *     * @param preuploadID 预上传ID - 必填     * @see &lt;a href=&quot;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/te21efi99a9edqd6&quot;&gt;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/te21efi99a9edqd6&lt;/a&gt;     */    public Map&lt;String, Object&gt; file_UploadCompleted(String preuploadID) &#123;        System.out.println(&quot;请求上传完毕API......&quot;);        Map&lt;String, Object&gt; body = new HashMap&lt;&gt;();        body.put(&quot;preuploadID&quot;, preuploadID);        HttpResponse&lt;String&gt; response = buildRequestPOST(&quot;/upload/v1/file/upload_complete&quot;, body);        return responseProcess(response, &quot;上传完毕&quot;);    &#125;    /**     * 异步轮询获取上传结果     *     * @param preuploadID 预上传ID - 必填     * @see &lt;a href=&quot;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/qgg0sxkfeqygam7e&quot;&gt;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/qgg0sxkfeqygam7e&lt;/a&gt;     */    public Map&lt;String, Object&gt; file_AsyncPollToObtainUploadResults(String preuploadID) &#123;        System.out.println(&quot;请求上传结果......&quot;);        Map&lt;String, Object&gt; body = new HashMap&lt;&gt;();        body.put(&quot;preuploadID&quot;, preuploadID);        HttpResponse&lt;String&gt; response = buildRequestPOST(&quot;/upload/v1/file/upload_async_result&quot;, body);        return responseProcess(response, &quot;异步轮询获取上传结果&quot;);    &#125;    /**     * 启用直链空间     *     * @param fileID 启用直链空间的文件夹的fileID - 必填     * @see &lt;a href=&quot;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/cl3gvdmho288d376&quot;&gt;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/cl3gvdmho288d376&lt;/a&gt;     */    public Map&lt;String, Object&gt; straight_EnableDirectLinkSpace(int fileID) &#123;        System.out.println(&quot;请求启用直链空间......&quot;);        Map&lt;String, Object&gt; body = new HashMap&lt;&gt;();        body.put(&quot;fileID&quot;, fileID);        HttpResponse&lt;String&gt; response = buildRequestPOST(&quot;/api/v1/direct-link/enable&quot;, body);        return responseProcess(response, &quot;启用直链空间&quot;);    &#125;    /**     * 禁用直链空间     *     * @param fileID 禁用直链空间的文件夹的fileID - 必填     * @see &lt;a href=&quot;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/ccgz6fwf25nd9psl&quot;&gt;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/ccgz6fwf25nd9psl&lt;/a&gt;     */    public Map&lt;String, Object&gt; straight_DisableDirectLinkSpace(int fileID) &#123;        System.out.println(&quot;请求禁用直链空间......&quot;);        Map&lt;String, Object&gt; body = new HashMap&lt;&gt;();        body.put(&quot;fileID&quot;, fileID);        HttpResponse&lt;String&gt; response = buildRequestPOST(&quot;/api/v1/direct-link/disable&quot;, body);        return responseProcess(response, &quot;禁用直链空间&quot;);    &#125;    /**     * 获取直链链接     *     * @param fileID 需要获取直链链接的文件的fileID - 必填     * @see &lt;a href=&quot;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/tdxfsmtemp4gu4o2&quot;&gt;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/tdxfsmtemp4gu4o2&lt;/a&gt;     */    public Map&lt;String, Object&gt; straight_GetADirectLink(int fileID) &#123;        System.out.println(&quot;请求获取直链......&quot;);        Map&lt;String, Object&gt; body = new HashMap&lt;&gt;();        body.put(&quot;fileID&quot;, fileID);        HttpResponse&lt;String&gt; response = buildRequestGET(&quot;/api/v1/direct-link/url&quot;, body);        return responseProcess(response, &quot;获取直链&quot;);    &#125;    /**     * 获取直链转码链接     *     * @param fileID 启用直链空间的文件夹的fileID - 必填     * @see &lt;a href=&quot;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/xz2uv5t7z8bfmbrg&quot;&gt;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/xz2uv5t7z8bfmbrg&lt;/a&gt;     */    public Map&lt;String, Object&gt; straight_GetDirectLinkTranscode(int fileID) &#123;        System.out.println(&quot;请求获取直链转码链接......&quot;);        Map&lt;String, Object&gt; body = new HashMap&lt;&gt;();        body.put(&quot;fileID&quot;, fileID);        HttpResponse&lt;String&gt; response = buildRequestGET(&quot;/api/v1/direct-link/get/m3u8&quot;, body);        return responseProcess(response, &quot;获取直链转码链接&quot;);    &#125;    /**     * 发起直链转码     *     * @param ids 需要转码的文件ID列表,请注意该文件必须要在直链空间下,且源文件是视频文件才能进行转码操作。&lt;br/&gt;     *            示例:[1,2,3,4]     * @see &lt;a href=&quot;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/wegmv21pgdfvolg4&quot;&gt;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/wegmv21pgdfvolg4&lt;/a&gt;     */    public Map&lt;String, Object&gt; straight_InitiateDirectChainTranscode(List&lt;String&gt; ids) &#123;        System.out.println(&quot;请求发起直链转码......&quot;);        Map&lt;String, Object&gt; body = new HashMap&lt;&gt;();        body.put(&quot;ids&quot;, ids);        HttpResponse&lt;String&gt; response = buildRequestPOST(&quot;/api/v1/direct-link/doTranscode&quot;, body);        return responseProcess(response, &quot;发起直链转码&quot;);    &#125;    /**     * 查询直链转码进度     *     * @param ids 视频文件ID列表。&lt;br/&gt;     *            示例:[1,2,3,4]     * @see &lt;a href=&quot;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/mf5nk6zbn7zvlgyt&quot;&gt;https://123yunpan.yuque.com/org-wiki-123yunpan-muaork/cr6ced/mf5nk6zbn7zvlgyt&lt;/a&gt;     */    public Map&lt;String, Object&gt; straight_QueryTranscodingProgress(List&lt;String&gt; ids) &#123;        System.out.println(&quot;请求查询直链转码进度......&quot;);        Map&lt;String, Object&gt; body = new HashMap&lt;&gt;();        body.put(&quot;ids&quot;, ids);        HttpResponse&lt;String&gt; response = buildRequestPOST(&quot;/api/v1/direct-link/queryTranscode&quot;, body);        return responseProcess(response, &quot;查询直链转码进度&quot;);    &#125;    /**     * 根据路径文件自动完成：请求、分片、上传 操作     *     * @param path      上传文件     * @param filename  文件名     * @param catalogID 存放在那个目录中，根目录为0     */    public Map&lt;String, Object&gt; uploadFile(String path, String filename, int catalogID) &#123;        // 结果集        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();        // 获取MD5以及大小        Map&lt;String, Object&gt; info = fileSizeAndMD5(path);        // 请求服务器创建文件        Map&lt;String, Object&gt; data = file_CreateFile(catalogID, filename, (String) info.get(&quot;md5&quot;), (Number) info.get(&quot;size&quot;));        // 如果是秒传则直接返回        if ((boolean) data.get(&quot;reuse&quot;)) &#123;            System.out.println(&quot;已秒传&quot;);            result.put(&quot;code&quot;, 0);            result.put(&quot;fileID&quot;, data.get(&quot;fileID&quot;));            return result;        &#125;        // 保存 preuploadID并分片        String preuploadID = (String) data.get(&quot;preuploadID&quot;);        Map&lt;String, Object&gt; splitFile = splitFile(path, (int) data.get(&quot;sliceSize&quot;));        // 保存上传文件的MD5值        int num = (Integer) splitFile.get(&quot;num&quot;);        String[] uploadMD5 = new String[num];        // 开始上传        for (int i = 0; i &lt; num; i++) &#123;            // 获取上传链接            Map&lt;String, Object&gt; obtainUploadURLData = file_ObtainUploadURL(preuploadID, i + 1);            // 上传分片并保存MD5值            String path1 = splitFile.get(&quot;path&quot;) + &quot;/&quot; + splitFile.get(&quot;fileName&quot;) + (i + 1) + &quot;.part&quot;;            uploadMD5[i] = (String) fileSizeAndMD5(path1).get(&quot;md5&quot;);            boolean uploadResults = uploadShardsPUT(path1, (String) obtainUploadURLData.get(&quot;presignedURL&quot;));            if (!uploadResults) &#123;                result.put(&quot;code&quot;, 1);                result.put(&quot;errorNum&quot;, (i + 1));                result.put(&quot;countNum&quot;, splitFile.get(&quot;num&quot;));                result.put(&quot;preuploadID&quot;, preuploadID);                return result;            &#125;        &#125;        // 如果文件原本的大小 &lt; sliceSize 那么不执行下面逻辑        if (!((long) info.get(&quot;size&quot;) &lt; (int) data.get(&quot;sliceSize&quot;))) &#123;            List&lt;Integer&gt; abnormalSharding = new ArrayList&lt;&gt;();            try &#123;                String map = mapper.writeValueAsString(file_ListUploadedParts(preuploadID));                // 循环校验md5值是否正确                for (int i = 0; i &lt; uploadMD5.length; i++) &#123;                    String md5 = mapper.readTree(map).get(&quot;parts&quot;).get(i).get(&quot;etag&quot;).asText();                    if (!md5.equals(uploadMD5[i])) abnormalSharding.add(i + 1);                    System.out.println(&quot;分片序号&quot; + (i + 1) + &quot;与云端校验结果 - &quot; + (md5.equals(uploadMD5[i]) ? &quot;一致&quot; : &quot;不一致&quot;));                &#125;                // 如果有异常分片则返回报错                if (!abnormalSharding.isEmpty()) &#123;                    System.out.println(&quot;分片MD5异常&quot;);                    result.put(&quot;code&quot;, 2);                    result.put(&quot;abnormalSharding&quot;, abnormalSharding);                    result.put(&quot;preuploadID&quot;, preuploadID);                    System.out.println(&quot;有MD5与服务器相匹配错误的分片，逻辑会继续执行，请在执行完毕之后检查云盘是否存在文件&quot;);                &#125;            &#125; catch (JsonProcessingException e) &#123;                throw new RuntimeException(&quot;Map转JSON失败&quot;);            &#125;        &#125;        // 上传完毕        Map&lt;String, Object&gt; uploadCompletedData = file_UploadCompleted(preuploadID);        if (!(boolean) uploadCompletedData.get(&quot;async&quot;)) &#123;            result.put(&quot;code&quot;, 0);            result.put(&quot;fileID&quot;, uploadCompletedData.get(&quot;fileID&quot;));            // 删除所有分片            deleteFolder((String) splitFile.get(&quot;path&quot;));            return result;        &#125; else &#123;            // 轮询请求 60 次            int retry = 0;            while (retry &lt;= 60) &#123;                // 请求合并结果                Map&lt;String, Object&gt; asyncData = file_AsyncPollToObtainUploadResults(preuploadID);                if (!(boolean) asyncData.get(&quot;completed&quot;)) &#123;                    // 没有获取数据，阻塞1.5秒后据徐请求                    try &#123;                        Thread.sleep(1500);                        retry++;                    &#125; catch (InterruptedException e) &#123;                        throw new RuntimeException(&quot;阻塞时间1.5秒&quot;);                    &#125;                &#125; else &#123;                    // 删除所有分片                    deleteFolder((String) splitFile.get(&quot;path&quot;));                    // 获取到返回数据                    result = new HashMap&lt;&gt;();                    result.put(&quot;code&quot;, 0);                    result.put(&quot;fileID&quot;, asyncData.get(&quot;fileID&quot;));                    return result;                &#125;            &#125;        &#125;        // 删除所有分片        deleteFolder((String) splitFile.get(&quot;path&quot;));        result.put(&quot;code&quot;, 2);        result.put(&quot;msg&quot;, &quot;需要异步查询上传结果&quot;);        result.put(&quot;preuploadID&quot;, preuploadID);        return result;    &#125;    /**     * 删除文件夹中所有内容     *     * @param deletePath 删除路径     */    private static void deleteFolder(String deletePath) &#123;        File folder = new File(deletePath);        File[] files = folder.listFiles();        if (files != null) &#123;            for (File file : files) &#123;                if (file.isDirectory()) &#123;                    // 递归删除子文件夹                    deleteFolder(file.getPath());                &#125; else &#123;                    // 删除文件                    if (!file.delete()) &#123;                        System.out.println(&quot;无法删除文件: &quot; + file);                    &#125;                &#125;            &#125;        &#125;        // 删除空文件夹或子文件夹已经被删除后的文件夹        if (!folder.delete()) &#123;            System.out.println(&quot;无法删除文件夹: &quot; + folder);        &#125;    &#125;    /**     * 上传文件并获取到响应的直链&lt;br/&gt;     * 一定要把文件上传到直链空间内     *     * @param path      上传文件     * @param filename  文件名     * @param catalogID 目录     */    public Map&lt;String, Object&gt; uploadFileAndGetDirectLink(String path, String filename, int catalogID) &#123;        // 上传文件        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();        Map&lt;String, Object&gt; uploadFile = uploadFile(path, filename, catalogID);        if ((int) uploadFile.get(&quot;code&quot;) == 0) &#123;            // 请求直链            int fileID = (int) uploadFile.get(&quot;fileID&quot;);            Map&lt;String, Object&gt; getADirectLink = straight_GetADirectLink(fileID);            result.put(&quot;fileID&quot;, fileID);            result.put(&quot;url&quot;, getADirectLink.get(&quot;url&quot;));            return result;        &#125; else &#123;            System.out.println(&quot;上传文件失败&quot;);            return uploadFile;        &#125;    &#125;    /**     * URL鉴权 - 防盗链&lt;br/&gt;     * 对直链进行加密     *     * @param url 加密URL     * @see &lt;a href=&quot;https://www.123pan.com/faq&quot;&gt;https://www.123pan.com/faq&lt;/a&gt;     */    public String URLAuthentication(String url) &#123;        try &#123;            // URL解码            url = URLDecoder.decode(url, StandardCharsets.UTF_8);            String path = new URL(url).getPath();            long timestamp = new Date().getTime() / 1000 + EXPIRED_TIME_SEC;            String randomUUID = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);            String unsignedStr = String.format(&quot;%s-%d-%s-%d-%s&quot;, path, timestamp, randomUUID, UID, PRIVATE_KEY);            // MD5加密            MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);            byte[] secretBytes = md5.digest(unsignedStr.getBytes());            StringBuilder md5str = new StringBuilder();            // 把数组每一字节换成16进制连成md5字符串            int digital;            for (byte aByte : secretBytes) &#123;                digital = aByte;                if (digital &lt; 0) digital += 256;                if (digital &lt; 16) md5str.append(&quot;0&quot;);                md5str.append(Integer.toHexString(digital));            &#125;            String md5sum = md5str.toString().toLowerCase();            return url + &quot;?auth_key=&quot; + String.format(&quot;%d-%s-%d-&quot;, timestamp, randomUUID, UID) + md5sum;        &#125; catch (MalformedURLException e) &#123;            throw new RuntimeException(&quot;无效的URL&quot;);        &#125; catch (NoSuchAlgorithmException e) &#123;            throw new RuntimeException(&quot;无效的算法&quot;);        &#125;    &#125;    /**     * 上传文件并获取鉴权链接     *     * @param path      上传文件     * @param filename  文件名     * @param catalogID 目录     */    public Map&lt;String, Object&gt; uploadFilesAndGetAuthenticationLink(String path, String filename, int catalogID) &#123;        // 上传文件        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();        Map&lt;String, Object&gt; uploadFile = uploadFile(path, filename, catalogID);        if ((int) uploadFile.get(&quot;code&quot;) == 0) &#123;            // 请求直链            int fileID = (int) uploadFile.get(&quot;fileID&quot;);            Map&lt;String, Object&gt; getADirectLink = straight_GetADirectLink(fileID);            // 获取防盗链            String authentication = URLAuthentication(getADirectLink.get(&quot;url&quot;).toString());            result.put(&quot;fileID&quot;, fileID);            result.put(&quot;url&quot;, getADirectLink.get(&quot;url&quot;));            result.put(&quot;authentication&quot;, authentication);            return result;        &#125; else &#123;            System.out.println(&quot;上传文件失败&quot;);            return uploadFile;        &#125;    &#125;&#125;\n\n","categories":["云盘"],"tags":["工具","java","代码","API","云盘"]},{"title":"BFC","url":"/2022/08/01/%E5%89%8D%E7%AB%AF/BFC/","content":"前言什么是BFC\nBFC   Block Formatting Context   块级格式化上下文\n简解：当元素开启 BFC 它自己就已经成为了一个独立的空间 也就是说这个 元素开辟了一个独立的空间然后这个元素的外部元素就不会受到这个 元素和这个元素内部元素的一个布局影响\n图文简解一共三个例子\n三个例子也是这个BFC它最主要要解决的三个问题\n第一个例子(解决父级元素高度坍塌)\n    \n        \n        \n            float\n        \n    \n\n\n\n\n假设有一个 div 然后这个 div 里面包含了两个子 div\n外面这个 div 它没有一个具体宽高,它的宽高完全是靠着两个子 div 的大小撑起来的\n如果说里面的两个 div 做了一个浮动(众所周知,一旦浮动的话就会脱离文档流)这样的话父元素的高度势必会坍塌(因为没有给他设置一个具体的高度)\n如果在这个坍塌的父元素的后面还有一个 div 因为第一个 div 的高度已经坍塌了就势必会造成第二个 div 的布局乱掉\n怎么解决呢\n因为是它的子元素浮动而造成的父元素高度坍塌所造成的影响\n所以可以给这个父级 div 开启一个BFC让它形成一个独立的空间,这样的话哪怕里面的元素再怎么浮动都不会影响到外面的元素的一个布局情况\n第二个例子(解决外边距重叠的问题)\n    \n        外边距10px\n        \n            高:100px宽:100px\n        \n        \n            高:100px宽:100px\n        \n        外边距10px\n    \n\n\n\n\n第一个方块的下外边距和第二个方块的上外边距都是10px加起来就是20px的外边距，但是上图的外边距明显不是，这就是外边距重叠了，一共只有10px的外边距\n怎么解决呢\n开启一个BFC它们外边距就不会再重叠起来了\n因为开启了BFC所以它们的空间都独立了所以它们相互之间就不会有任何干扰哪怕是外边距\n第三个例子(解决自适应布局的问题)\n    \n        导航\n    \n    \n        可以根据屏幕大小自适应的内容\n    \n\n\n\n\n左边做一个导航,右边是一个可以根据屏幕大小而自适应的一些内容\n让内容自适应屏幕的一个宽度,给导航栏 div 做了一个浮动它会重叠在内容 div 的上面 如下所示\n\n    \n        \n            导航\n        \n        \n            可以根据屏幕大小自适应的内容\n        \n    \n\n\n\n\n但是如果内容变多了,那么它的内容会跑到导航栏的下面 如下所示 这种效果就很有可能不是我们希望看到的\n\n    \n        \n            导航\n        \n        \n            可以根据屏幕大小自适应的内容我是多出来的\n        \n    \n\n\n\n\n这样就可以给那个做内容的开启一个BFC这样它俩就不会再有干扰了 如本例第一幅图\n因为它还是块级元素还是尽可能的把这一行占满的所以还是可以做一个自适应\n如何触发BFC\n根元素(&lt; html &gt;)\n浮动元素(元素的float不是none)\n绝对定位元素(元素的position为absolute或fixe)\ndisplay为 inline-block、 table、 table-cell、 table-caption、 table-row、 table-row-group、 table-header-group、 table-column-group、 inline-table、 flow-root、 flex或 inline-flex、 grid或 inline-grid\noverflow值不为visible的块元素\ncontain值为layout、content或paint的元素\n多列容器(元素的column-count或column-width不为auto,包括column-count为 1)\n\n/* 日常开发中应用的最多触发BFC的方法 */overflow: hidden;display: block;display: table-cell;position: absolute;position: fixed;    \n\n虽然方法都可以触发BFC但是表达出来的效果是不一样的\n比如**position: absolute;和position: fixed;**一个是固定定位一个是绝对定位最终表现得形式是不一样的\n","categories":["前端"],"tags":["CSS","BFC"]},{"title":"H5代码高亮加行号","url":"/2022/07/11/%E5%89%8D%E7%AB%AF/H5%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E5%8A%A0%E8%A1%8C%E5%8F%B7/","content":"前言在网页的使用过程中，经常会有代码展示的必要。而不同颜色的关键词，可以让代码看起来更直观、更美观,本文教如何进行代码高亮并显示行号\n代码进行高亮highlight.js是一款基于JavaScript的语法高亮库，目前支持125种编程语言，有63种可供选择的样式，而且能够做到语言自动识别 ，和目前主流的JS框架都能兼容，比较实用，而且用起来炒鸡简单！效果如下行所示\n&lt;p&gt; 这是一行高亮代码&lt;/p&gt; \n\n现在来进行操作\n本文使用的所有文件都可以在结尾处获取，也可自行下载\n步骤一：获取highlight有两种方法(只用其中一种即可)，不管哪个方法都得去官网,任意一种都管用,网址: https://highlightjs.org\n方法一：去官网下载文件使用\n点击**获取版本(Get version)**按钮进入语言选择，往下滑，勾选常用的语言，在使用插件时会自动检测你要展示的代码的语言， 并自动让代码高亮。通常common就足够用了\n\n选好文件之后,往下滑，点击 Download进行下载\n\nstyles目录下是所有的css样式，决定代码的颜色\n有很多样式，可以参考官方文档: https://highlightjs.org/static/demo\n 我用的是felipec.min.css\nhighlight.min.js为库文件，决定代码哪些部分会变高亮\n然后引入文件：\n&lt;!-- css文件位置可以更改,按照自己文件路径更改即可 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;../../gao-liang/styles/felipec.min.css&quot;&gt;&lt;script src=&quot;../../gao-liang/highlight.min.js&quot;&gt;&lt;/script&gt;\n\n\n\n方法二：找官网CDN还是点**获取版本(Get version)**按钮进入，然后第一个就是\n\n把第一个cdnjs里面的内容给链接上\n&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/felipec.min.css&quot;&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js&quot;&gt;&lt;/script&gt;\n\n这样就大功告成了\n步骤二：加载highlight.js库&lt;script&gt;    hljs.initHighlightingOnLoad(); //初始化 建议写到head里面&lt;/script&gt;  \n\n\n\n步骤三：在&lt;pre&gt;和&lt;code&gt;标签中添加要显示的代码&lt;pre&gt;&lt;code class=&quot;HTML&quot;&gt;        &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;zh-CN&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;        &lt;title&gt;高亮显示&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;p&gt;现在所显示的代码是高亮哦&lt;/p&gt;    &lt;/body&gt;    &lt;/html&gt;&lt;/code&gt;&lt;/pre&gt;\n\n系统会自动检测你的代码的语言，如果不放心的话，可以在&lt;code&gt;标签中用class属性指定语言类别，上面代码中指定为HTML语言\n高亮结束–注意！！！代码里包含标签，记得将标签里的 &lt;** 换成 **&amp;lt;** ，把 **&gt; 换成 &amp;gt ; 否则会被游览器解析为正常标签，导致显示代码\n选择方法二的时候从官方那里复制的cdn的“**&#x2F;&#x2F;”前面要加上“https:**”，有时候不加这个的话高亮会失灵\n要显示的代码有两个语言,只亮了其中一种语言,另一种不亮,这个可以先class决定要亮哪种语言,另一种不亮的可以用注释来使其亮起\n比如在HTML页里面写了 script 标签，里面写了内容，输出时，标签亮了，但是标签里面的内容没有亮，这时可以在未亮的代码后面加入语言不同的注释\n如HTML的注释是：&lt; !–  注释内容  – &gt;\n如CSS的注释是：&#x2F;*  *&#x2F;\n如JavaScript的注释是：&#x2F;&#x2F;\n其他语言是否能成功不晓得，但是至少在HTML页面里，script 标签里面的 JS 部分代码就是这样亮的\n行号弄好的高亮里面是没有行号的，所以还要进行行号的配置\n下载文件下载添加行号js文件：https://github.com/wcoder/highlightjs-line-numbers.js\n因为是在GitHub上面的，所以有时候会出现进不去的情况，遇到这种情况等待一会就好了\n引入文件&lt;!-- 具体路径看你把文件放在了哪里 --&gt;\t&lt;script src=&quot;../../gao-liang--hang-hao/highlightjs-line-numbers.js&quot;&gt;&lt;/script&gt;\n\n\n\n加入代码&lt;script&gt;    hljs.initLineNumbersOnLoad();//这个不是上面高亮的代码&lt;/script&gt;\n\n\n\n添加行号样式&lt;style&gt;  .hljs-ln-numbers &#123;      text-align: center;      color: #ccc;      border-right: 1px solid #999;&lt;/style&gt;\n\n完事，ok了，按照高亮部分的格式正常书写就行了\n结尾一共只需要三个文件加四行代码\n&lt;!-- 代码高亮 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;../../gao-liang--hang-hao/felipec.min.css&quot;&gt;&lt;script src=&quot;../../gao-liang--hang-hao/highlight.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 行号显示 --&gt;&lt;script src=&quot;../../gao-liang--hang-hao/highlightjs-line-numbers.js&quot;&gt;&lt;/script&gt;&lt;!-- 初始化 --&gt;&lt;script&gt;    hljs.initHighlightingOnLoad(); //高亮    hljs.initLineNumbersOnLoad(); //行号&lt;/script&gt;\n\n这里是打包好的单独的文件(高亮-行号)\n高亮只支持HTML,CSS,JS,C,C++,C#,SQL,JSON,JAVA版本:11.6.0\n文件：点击下载\n","categories":["前端"],"tags":["代码","高亮"]},{"title":"元素关系","url":"/2022/07/10/%E5%89%8D%E7%AB%AF/%E5%85%83%E7%B4%A0%E5%85%B3%E7%B3%BB/","content":"元素关系父元素：直接包含子元素的元素\n子元素：直接被父元素包含的元素\n祖先元素：直接或间接包含后代元素的元素，父元素也是祖先元素\n后代元素：直接或间接被祖先元素包含的元素，子元素也是后代元素\n兄弟元素：拥有相同父元素的元素叫做兄弟元素\n元素属性行内元素\n行内元素会在一条直线上排列，在同一行从左至右水平排列。直到一行排不下，才会换行\n行内元素设置宽、高、margin上下、padding上下无效（竖直无效）\n行内元素设置line-height，margin左右、padding左右有效（水平有效）\n行内元素的宽高随标签里的内容而变化\n\n行内元素在浏览器中默认与其它行内元素共占一行。只有当多个行内元素的总宽度大于浏览器的宽度时，才会换行显示\n总的来说，行内元素一般都是基于语义级(semantic)的基本元素，它只能容纳文本或者其他行内元素，通常被包括在块元素中使用\n常见内联元素有“a、b、br” 等\n块元素块级元素（block element）在浏览器中占据整行，并排斥其它元素与其位于同一行。也就是说，块级元素的宽度是 100%\n块级元素的宽度是 100%，在浏览器中默认独占一行\n块级元素内部可以嵌套块级元素或行内元素\n行内块元素行内块级元素，它既具有块级元素的特点，也有行内元素的特点，它可以自由设置元素宽度和高度，也可以在一行中放置多个行内块级元素\n和其他行内或行内块级元素元素放置在同一行上\n元素的高度、宽度、行高以及顶和底边距都可设置\n替换元素替换元素就是浏览器根据元素的标签和属性，来决定元素的具体显示内容\n替换元素是其内容不受CSS视觉格式化模型控制的元素，例如img标签，嵌入的文档（iframe之类）或者applet，这些叫做替换元素\n比如img元素通过src属性的值来读取图片信息并显示出来，而如果查看(x)html代码，却看不到图片的实际内容，而且img元素的内容通常会被src属性指定的图像替换掉\n例如input元素的type属性决定是显示输入框，还是单选按钮等\n转换元素（此过程需用CSS进行转换）\n\n\nCSS属性\n效果\n\n\n\ndisplay：block\n定义元素为块级元素\n\n\ndisplay : inline\n定义元素为行内元素\n\n\ndisplay：inline-block\n定义元素为行内块级元素\n\n\n","categories":["前端"],"tags":["前端","元素"]},{"title":"日历小案例","url":"/2023/10/12/%E5%89%8D%E7%AB%AF/%E6%97%A5%E5%8E%86%E5%B0%8F%E6%A1%88%E4%BE%8B/","content":"成品\n    \n        * {\n            padding: 0;\n            margin: 0;\n            box-sizing: border-box;\n        }\n        #calendar {\n            width: 300px;\n            background-color: rgb(255, 251, 240);\n            border-radius: 10px;\n            margin: auto;\n        }\n        #yue {\n            border-radius: 10px 10px 0 0;\n            width: 100%;\n            height: 140px;\n            margin-bottom: 10px;\n            background-image: url(https://img.zcool.cn/community/0112bb5d77c95ea801211d53761186.gif);\n            background-size: cover;\n            position: relative;\n        }\n        #yue>span {\n            font-size: 50px;\n            color: rgb(95, 255, 250);\n            position: absolute;\n            bottom: 20px;\n            right: 20px;\n        }\n        #rl {\n            width: 100%;\n            padding: 5px 10px 10px 10px;\n        }\n        #rl span {\n            display: inline-block;\n            width: 35px;\n            text-align: center;\n            height: 25px;\n        }\n        #rl>div>span {\n            color: rgb(207, 165, 255);\n            border-bottom: 2px solid pink;\n            margin-bottom: 10px;\n        }\n        #rl>div>div span {\n            font-weight: 600;\n        }\n    \n    \n        \n            \n        \n        \n            \n                一\n                二\n                三\n                四\n                五\n                六\n                日\n            \n            \n                \n                    \n                    \n                    \n                    \n                    \n                    \n                    \n                \n                \n                    \n                    \n                    \n                    \n                    \n                    \n                    \n                \n                \n                    \n                    \n                    \n                    \n                    \n                    \n                    \n                \n                \n                    \n                    \n                    \n                    \n                    \n                    \n                    \n                \n                \n                    \n                    \n                    \n                    \n                    \n                    \n                    \n                \n                \n                    \n                    \n                    \n                    \n                    \n                    \n                    \n                \n            \n        \n    \n    \n        var date = new Date();\n        // 月份\n        var yues = document.querySelector('#yue>span');\n        yues.innerHTML = date.getMonth() + 1;\n        // 获取月份天数\n        function getDays(year, month) {\n            let days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n            if ((year % 4 === 0) && (year % 100 !== 0 || year % 400 === 0)) {\n                days[1] = 29;\n            }\n            return days[month]\n        }\n        // 详细日期\n        var yue = date.getMonth();\n        var qi = getDays(date.getFullYear(), yue);\n        // 求出每月第一天是周几\n        var xingqi = date.getDay();\n        xingqi = xingqi === 0 ? 7 : xingqi;\n        for (let i = 0; i < parseInt(date.getDate() % 7) - 1; i++) {\n            xingqi--;\n            if (xingqi === 0) xingqi = 7;\n        }\n        // 输出日历\n        xingqi--;\n        var td = document.querySelectorAll('#rl>div>div span');\n        for (let i = 0; i < xingqi; i++) {\n            td[i].innerText = '😈';\n        }\n        for (let i = xingqi; i ","categories":["前端"],"tags":["前端","小实例","日历"]},{"title":"纯前端实现密码保护文件访问","url":"/2025/12/26/%E5%89%8D%E7%AB%AF/%E7%BA%AF%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E4%BF%9D%E6%8A%A4%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE/","content":"\n场景：需要在纯前端的环境中让一组 JSON 文件只有通过输入正确的密码才能进行访问\n\n在纯前端环境中基本上没有什么安全性可言所有东西都是硬编码在里面的，所以要实现以上功能我只能取个巧，利用随机目录名（前提是服务器禁止遍历目录名）然后把受保护的 JSON 放到该目录下来实现。顺着这个思路，我要做的就是输入一个密码，然后得到一个目录名，最后通过该目录名来访问受保护的 JSON 文件。\ngraph TD\n\n开始(输入密码) --> 操作(中间操作)\n操作 --> 结果(目录名)\n\n加密现在实现中间操作，在构建项目的时候需要生成并保存一个 JSON 对象（update_info.json）：\n&#123;  &quot;updateId&quot;: &quot;&quot;,  &quot;updateTime&quot;: &quot;&quot;&#125;\n\n对象的 updateTime 属性就是构建项目时的时间戳，而 updateId 就是则是时间戳和密码的MD5值（KEY） + 时间戳 组合计算的MD5值。\ngraph TD\n\n时间戳1[时间戳（updateTime）] --> KEY\n密码 --> KEY[KEY（MD5）]\nKEY --> updateId[updateId（MD5）]\n时间戳2[时间戳（updateTime）] --> updateId\n\n而最重要的目录名则是 updateId + KEY 计算而成的MD5值。\ngraph TD\n\nKEY[KEY（MD5）] --> 目录名[目录名（MD5）]\nupdateId[updateId（MD5）] --> 目录名[目录名（MD5）]\n\n以上就是加密目录名生成过程，到时候把需要保护的 JSON 文件放到该目录下即可\n解密首先获取需要先去把 update_info.json 文件请求下来，然后解析出 updateId 和 updateTime。\ngraph TD\n初始化(请求 update_info.json 文件)\n初始化 --解析--> updateId[校验 updateId]\n初始化 --解析--> updateTime\n\n然后通过输入的密码和 updateTime 来计算出 KEY，通过这个 KEY 来在加上 updateTime 计算出来的 updateId 来和服务器返回的 updateId 进行对比，若一致则说明密码正确，否则密码错误。\n密码正确后就可以通过 updateId + KEY 来计算出目录名，然后就可以访问受保护的 JSON 文件了\ngraph TD\n\n开始(输入密码) --> KEY\nupdateTime1[updateTime] --> KEY\n\nKEY --> updateId\nupdateTime2[updateTime] --> updateId\n\nupdateId -->判断updateId{判断计算出来的和 update_info 文件中的两个 updateId 是否一致}\n判断updateId -- 不一致 --> 错误(密码错误)\n判断updateId -- 一致 --> KEY2[KEY（MD5）]\n\nupdateId2[updateId（MD5）] --> 结果(目录名（MD5）)\nKEY2 --> 结果\nKEY2 --> 额外操作[存储 KEY]\n\n在这期间如果密码输入错误，即计算出来的 updateId 与服务器返回的 updateId 不一致，那么强行使用 KEY 计算出来的目录名也必然时错误的\n同时在校验成功后需要把 KEY 存储起来，后续就可以凭借着这个 KEY 来访问受保护的 JSON 文件，而不需要再次输入密码。并且密码也不会被存储到任何地方，仅参与一下 KEY 的计算\n而且伴随着每次触发新的部署，时间戳也会同步更新，也就会生成新的 目录名，以前的 KEY 也会失效，所有的一切都是基于新的时间戳和密码计算出来的\n这样一来也就达到了在纯前端的环境下实现用密码来保护资源文件的目的\n","categories":["前端"],"tags":["案例","前端","密码保护","JSON","想法"]},{"title":"静态网页统计访问次数","url":"/2022/08/12/%E5%89%8D%E7%AB%AF/%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%BB%9F%E8%AE%A1%E8%AE%BF%E9%97%AE%E6%AC%A1%E6%95%B0/","content":"前言众所周知静态网页是不能够显示访问次数， 得需要用数据库来进行存储数据， 但是今天我发现一个好东西， 引入JS就可以实现 站点总访问量 站点访客数 单页访问量  在本地的时候会显示有很多次数,但是挂载到网站就显示正常了。 站点访客数有个小毛病,就是退出游览器在重新进入也算一个人,所以不怎么准\n工具不蒜子 官网地址:http://busuanzi.ibruce.info/\n实操首先将以下内容复制在主页上，比如index.html\n先引入JavaScript代码&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;\n\n\n\n显示数字用的代码&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;    本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;    本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/span&gt;\n\n上面的第一个是计算PV量，第二个是计算UV量\n下面的是单页面访问量一般于博客文章中加入,显示这张内容被看过几次\n&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;    本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;\n\n\n\n小知识PV（Page View）访问量\n即页面浏览量或点击量，衡量网站用户访问的网页数量； 在一定统计周期内用户每打开或刷新一个页面就记录1次， 多次打开或刷新同一页面则浏览量累计。\nUV（Unique Visitor）独立访客\n统计1天内访问某站点的用户数(以cookie为依据); 访问网站的一台电脑客户端为一个访客。可以理解成访问某网站的电脑的数量。 网站判断来访电脑的身份是通过来访电脑的cookies实现的。 如果更换了IP后但不清除cookies，再访问相同网站，该网站的统计中UV数是不变的。 如果用户不保存cookies访问、清除了cookies或者更换设备访问，计数会加1。 00:00-24:00内相同的客户端多次访问只计为1个访客 当然本文的UV量是只要退出游览器在进入访问网站计数就会+1\n","categories":["前端"],"tags":["小知识","工具"]},{"title":"NVM","url":"/2024/06/25/%E5%B7%A5%E5%85%B7/NVM/","content":"简介在不同的前端项目中，Node版本之间的有时候会不兼容，然后需要对相对应的项目下载不同的Node版本，这很繁琐，而且很麻烦\n然后，我找到了 nvm 这个专门为 Node 版本控制而生的版本控制工具，这款软件轻量而且强大\n地址中文网：https://nvm.uihtm.com\nGitHub：https://github.com/coreybutler/nvm-windows/releases\n使用安装好软件之后，打开黑窗口然后输入 mvn -v 看看能不能输出版本号，有输出代表安装成功\n然后进行切换镜像源，执行以下其中一组命令\n阿里：\nnvm npm_mirror https://npmmirror.com/mirrors/npm/nvm node_mirror https://npmmirror.com/mirrors/node/\n\n腾讯：\nnvm npm_mirror http://mirrors.cloud.tencent.com/npm/nvm node_mirror http://mirrors.cloud.tencent.com/nodejs-release/\n\n命令nvm arch：显示node是运行在32位还是64位。\nnvm install &lt;version&gt; [arch] ：安装node， version是特定版本也可以是最新稳定版本latest。可选参数arch指定安装32位还是64位版本，默认是系统位数。可以添加–insecure绕过远程服务器的SSL。\nnvm list [available] ：显示已安装的列表。可选参数available，显示可安装的所有版本。list可简化为ls。\nnvm on ：开启node.js版本管理。\nnvm off ：关闭node.js版本管理。\nnvm proxy [url] ：设置下载代理。不加可选参数url，显示当前代理。将url设置为none则移除代理。\nnvm node_mirror [url] ：设置node镜像。默认是https://nodejs.org/dist/。如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。\nnvm npm_mirror [url] ：设置npm镜像。https://github.com/npm/cli/archive/。如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。\nnvm uninstall &lt;version&gt; ：卸载指定版本node。\nnvm use [version] [arch] ：使用制定版本node。可指定32&#x2F;64位。\nnvm root [path] ：设置存储不同版本node的目录。如果未设置，默认使用当前目录。\nnvm version ：显示nvm版本。version可简化为v。\n安装版本当已经安装好一个node版本后并不能直接使用，这时候使用 list 命令显示的版本号查看版本前面有没有 * ，带的就代表了当前正在使用的版本，没有的话使用 use 命令指定一下版本号，这时会发现在启用的 node 版本前面有 * 标记，这时就可以使用 node\nnpm 镜像（看情况）查看当前的镜像源：npm get registry\n设置指定镜像源：npm config set registry [url]\n切换回官方镜像源：npm config set registry http://www.npmjs.org/\n安装镜像源管理工具：npm install -g nrm\n查看当前可用镜像源：nrm ls\n切换到指定镜像源：nrm use cnpm\n\n腾讯镜像源地址：http://mirrors.cloud.tencent.com/npm/\n\n","categories":["工具"],"tags":["工具","版本工具"]},{"title":"B树与B+树","url":"/2024/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/B%E6%A0%91%E4%B8%8EB+%E6%A0%91/","content":"B树这B树是一个多叉平衡搜索树，这种树在大数据量的情况下他要比二叉搜索树、红黑树要好的。因为二叉搜索树和红黑树都是先把数据给加载到内存中，然后再对其进行处理的。\n内存呢现在一般就是GB级别的，比如16G、32G，这种通常处理的数据量通常不会很大。如果要是处理的数据量规模非常大的话那么就需要把数据给存到容量更改的硬盘里了，当今TB级别的硬盘已经是非常常见的了。\n因为无法一次性的把大规模的数据全部读取到内存中，那么当需要处理某些数据的时候，去找硬盘上到数据然后把它读取到内存中再进行处理。\n\n问题：为什么一定要读取到内存中再处理数据呢？\n解答：操作数据是需要CPU去执行相关的指令的，而CPU是不能和硬盘直接交互的。至于原因嘛就是因为CPU太快了，硬盘跟不上CPU的速度，所以得需要内存这个中间人去协调两边。所以想要处理硬盘内的数据需要先把数据给读到内存中然后再进行交互。整个过被称做一次硬盘的访问，也可以叫一次硬盘io\n\n\n在上图中，假设这些内容都是存在于磁盘中，那么每一次对节点的访问就是一次磁盘的IO。\n如果我需要找到13这个数，那么我会经历以下几步\n\n第一次访问磁盘找到根节点11- 小\n第二次访问磁盘找到节点17 - 大\n第三次访问磁盘找到节点14 - 大\n第四次访问磁盘找到节点13 - 正确\n\n所以根据以上的流程，我找到13需要4此的磁盘IO，所以由此得出在这种数据结构中硬盘的访问次数和树的高度是正相关的。同理想要减少磁盘的io只需要减少树的高度即可！此时B树就应运而生了\nB树和这种二叉树和红黑树最大的不同就是B树可以有多个分叉，每一个节点不止有一个元素。\n\n问题：书的高度是降低了，但是元素个数增加了，这不会增加更多的耗时嘛？\n解答：硬盘读取物理地址连读的多个字节和读取单个字节的耗时几乎没有区别；B树的访问节点是在硬盘上进行的，节点内的数据操作是在内存中进行的\n\n以下就是一颗B树，可以看到以下分叉最多就是5个，所以这是一个5阶B树（这个阶数不是固定的）\n\n特性作为一颗B树，那必须满足三个特性：平衡、有序、多路\n平衡：B树的叶子节点一定是在同一层的\n有序：B树任何一个节点中的数据都是有顺序的。任一元素的左子树都小于它，右子树都大于它\n多路：\n\nm阶的B树也是一颗m叉树\n上限：他的最大的分叉一定等于m，最多有m-1个元素\n下线：根节点最少有2个分支1个元素、其他节点则最少需要有（m &#x2F; 2 + 向上取整）个分支和（m &#x2F; 2 - 1 + 向上取整）个元素\n\n查找\n以上图为例，查找45\n\n跟17比较 - 小 - 走右边\n跟23比较 - 小\n跟35比较 - 小\n跟47比较 - 大 - 此时走47的左子树也是35的右子树\n跟38比较 - 小\n跟45比较 - 正确\n\n插入插入的画也是得先进行比较，还是以上面的图为例插入39\n\n跟17比较 - 小 - 走右边\n跟23比较 - 小\n跟35比较 - 小\n跟47比较 - 大 - 此时走47的左子树也是35的右子树\n跟38比较 - 小\n跟45比较 - 大 - 此时判断当前节点是否为叶子节点是的话在后面插入\n\n得到下图\n\n并且如果数据到达了上线则会进行分裂，一直分裂到满足特性为止，就比如我需要再次添加两个数据40、41\n\n跟17比较 - 小 - 走右边\n……\n40插入完成 - 开始插入41\n……\n跟45比较 - 大 - 此时判断当前节点是否为叶子节点是的话在后面插入\n41插入完成 - 此时判断一下元素个数是否等于5（因为是5阶B树） - 满足条件开始分裂\n在 38 39 40 41 45 这五个数据中经过 5 &#x2F; 2 + 向上取整 得到结果3\n把第三个数据给父节点，在父节点中排序插入 - 此时判断一下父元素个数是否等于5\n…….\n\n最后得到下图\n\n这就是分裂完成的B树，如果达到上限他就会一直分裂，哪怕是根节点也是如此。所以他也是从下往上进行成长的树\n\n插入的位置一定是在叶子节点上进行插入的\n\n删除\n删除操作在这里面就是替换操作，删除的内容最终都是叶子节点\n\n在删除非叶子节点的数据的时候就需要使用该元素的直接前驱或者后继去替换\n\n比如上图删除17那么找到17的前驱16后继19这两个任意一个进行替换然后把那个元素删除即可，这里我是用后继19去替换17，然后删除原来的19即可，最后得到下图\n\n如果是叶子节点的画直接删除就行了\n\n注意：在删除元素的时候需要保证B树的特定，在删除中就是多路里的下线（根节点最少有2个分支1个元素、其他节点则最少需要有 m &#x2F; 2 + 向上取整 个分支和 m &#x2F; 2 - 1 + 向上取整 个元素）\n\n异常情况比如在删除34的时候就会出现异常，5阶B树其他节点中元素个数必须有2个。这种情况就得需要向左右两边的兄弟借一个元素过来，左边兄弟20 22这个不能借，因为也会出现异常；右边的兄弟有三个数据那么就可以向右边兄弟借一个元素\n但是在借的时候不能直接把38这个元素要过来，因为这样会破坏B树有序的特性，所以想要借到38那么他们的父级元素35就得跟着变一变。让35移步到34的位置，让38移步到35的位置，最后在删除38。让父变子，兄变父，这样不仅借到了元素，而且也保证的B树的有序性\n删除结果如下图所示\n\n另一种情况，如果左右兄弟都没有办法借那就只能进行合并的操作。比如删除35时就会出现这种情况。\n删除35时左右兄弟都没办法借到元素那就只能向左右种地中任意一个进行合并。比如向20 22这个节点中进行合并，因为考虑到有序性所以得让27和20 22节点的父元素23移步到20 22节点中然后再合并27。如下图\n\n上面这就是拆一下父元素然后合并完成了删除，既然父元素能够拆那么父元素就肯定会出现异常的情况。比如我需要删除6就会出现\n再我删除6时找到6的后继节点中的数据8补上然后把6删除出现下图\n\n此时11这个节点不满足下线那么进行左右兄弟找一个合并，我选择合并左边的，就会出现下图\n\n此时父节点就会出现异常，这种情况就得找到13的兄弟节点去借一个数据，按照之前说的父变子，兄变父但是与之前不同的时因为兄弟节点还有一个子分支，我们还需要把这个子分支也给移动过来，如下图\n\n还有一种情况，就是两个父元素也不够借的时候那就只能降低树的高度了。比如删除39所出现的情况\n在删除39后只剩下45那么就会出现异常，45节点没有左兄弟那么只能合并右兄弟，最后得到的结果如下图所示\n\n这时候异常就出现了，那么这种情况就是55往13 19这个节点合并，流程就是根节点38移步到13 19这个节点中然后55这个节点带着他的子节点合并过来，结果如下\n\n最后树被砍掉一层\nB+树\n各种资料上B+树的定义各有不同，一种定义方式是关键字个数和孩子结点个数相同，还有一种定义方式是关键字个数比孩子结点个数小1。以下我采用第二种方式，即关键字个数比孩子结点个数小1，这种方式是和B树基本等价的。\n\nB+树是由B树演变而来的一种树，常常用来作为数据库的索引。B+树和B树非常的相像，但是B+树的所有数据都是存在与叶子节点上的，它的内部节点（非叶子节点）存放的是叶子节点的索引。什么意思呢？B+树的内部节点的作用就是为了快速找到存放数据的叶子节点的\n在B树中想要找到某个节点可以使用随机查找，也就是比较查找。但是进行顺序遍历的时候就得使用中序遍历的方式，因为中序遍历的顺序是有序的。这让就会在节点上不停的跳转，效率比较低。B+树的出现就解决了这一个槽点，以下就是一颗5阶B+树\n\n可以看到，他的所有数据都在叶子节点上，这样在随机查找的时候就可以从根节点快速的查找数据，而需要顺序遍历的时候只需要把叶子节点遍历一遍即可（叶子节点之间是存在链表关系的，比如1 2 3这个节点它链接的下一个节点是4 5 6）\n特性B+树包含2种类型的结点：内部结点（也称索引结点）和叶子结点。根结点本身即可以是内部结点，也可以是叶子结点。根结点的关键字个数最少可以只有1个。\nB+树与B树最大的不同是内部结点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子结点中。\nm阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个子树），阶数m同时限制了叶子结点最多存储m-1个记录。\n内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。\n每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。\n查找顺序查找：比如我要查找一个数字15，在顺序查找的时候从头节点（1 2 3）开始查找，因为叶子节点之间是存在链表关系的，所以从前往后开始遍历很快就可以找到\n随机查找：还是查找14，从根节点（13 25）开始查找\n\n跟13比较 - 小\n跟25比较 - 大 - 此时走25的左子树也是13的右子树，所以走25的左子树\n找到16 19 22这个节点\n跟16比较 - 小 - 走16的左子树\n跟13比较 - 小\n跟14比较 - 相等 - 找到了\n\n混合查找：查找5~13之间的数据\n\n先通过随机查找找到最小数5\n……\n找到之后通过链表开始往后遍历\n……\n最后遍历到14的位置发现大于13停止遍历\n\n插入\n所有插入的数据都是插入到叶子节点上的，再插入之前都会先去比较一下数据，看看当前元素需要插入到哪个位置\n\n从0开始构建一颗5阶B+树。首先第一个节点它既是根节点也是叶子节点里面有元素1 2 3 4，然后添加5此时该节点出现了上溢出开始分裂。1 2 3是一个叶子节点，4 5是一个叶子节点，他们的父节点元素是4如下图\n\n此时父节点也就是索引节点就创建好了，然后继续添加6、7、8三个数据发现4 5这个节点会发生上溢出此时再次进行分裂，如下图\n\n再次添加若干个数据之后会出现下图情况\n\n此时再次添加一个数据17就会最后一个元素就会发生分裂，但是分裂后父节点的元素也会上溢出，此时父节点也得跟着分裂，但是跟叶子节点的分裂不一样。\n叶子节点分裂他不会把m &#x2F; 2 + 1 + 向上取整的元素给移动到上面而是上面存在他的索引元素本身还在叶子节点中。\n而内部节点它的分裂就是B树的正常分裂了，最后结果如下图\n\n","categories":["数据结构"],"tags":["B树","B+树","Tree"]},{"title":"滑动窗口","url":"/2023/11/14/%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/","content":"介绍滑动窗口法，也叫尺取法，可以用来解决一些查找满足一定条件的连续区间的性质的问题。\n思想就按照查找不含有重复字符的最长子串的长度来举例（abcabcbb）\n现有两个变量用来当左边和右边的下标（这里以括号表示），满足要求的时候，右括号往右走，如下所示\n(a) b c a b c b b  –&gt;   (a b) c a b c b b  –&gt;   (a b c) a b c b b  –&gt;   (a b c a) b c b b\n右括号一直走，直到其中包含重复字符也就是两个a，这是右括号停止走并记录此时的最大值也就是3（abc）\n不满足的时候左括号开始走\n(a b c a) b c b b  –&gt;  a (b c a) b c b b\n此时可以看到括号里面的内容是只有 bca 的，那么满足条件右括号开始走\na (b c a) b c b b  –&gt;  a (b c a b) c b b\n可以看到里面又有重复字符了，此时左括号开始走，并记录最大值，还是3（bca）\na (b c a b) c b b  –&gt;  a b (c a b) c b b\t左\na b (c a b) c b b  –&gt;  a b (c a b c) b b    右\na b (c a b c) b b  –&gt;  a b c (a b c) b b    左\na b c (a b c) b b  –&gt;  a b c (a b c b) b    右\na b c (a b c b) b  –&gt;  a b c a (b c b) b  –&gt;  a b c a b (c b) b    左\na b c a b (c b) b  –&gt;  a b c a b (c b b)    右\na b c a b (c b b)  –&gt;  a b c a b c (b b)  –&gt;  a b c a b c b (b)    左\n上面就是整个的执行流程，就像是可变的可视化区域由左向右活动一样\n","categories":["算法"],"tags":["算法"]},{"title":"经典算法","url":"/2023/02/03/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/","content":"排序算法冒泡排序冒泡排序，就跟金鱼吐泡泡一样，其原理就是，第一个数跟第二个数进行比较（从小到大），如果第一个比第二个大，那么他们两个数据就进行交换，然后第二个与第三个进行比较，如果不大于那么数据进行下一次排序\n\n特点是第一次排序肯定会把最大的或者最小的数排出来\n\n\n\n\n\n时间复杂度\n空间复杂度\n是否稳定\n\n\n\nO(n^2)\nO(1)\n稳定\n\n\n代码#include &lt;stdio.h&gt;int main() &#123;    int a[10];    for (int i = 0; i &lt; 10; ++i) &#123;        printf(&quot;请输入第%d个元素数据:&quot;, i + 1);        scanf(&quot;%d&quot;, &amp;a[i]);    &#125;    for (int i = 0; i &lt; 10; ++i) &#123;        printf(&quot;%d &quot;, a[i]);    &#125;    printf(&quot;\\n----------冒 泡 前----------\\n&quot;);    for (int i = 0; i &lt; 10 - 1; ++i) &#123;        for (int j = 0; j &lt; 10 - i - 1; ++j) &#123;            if (a[j] &gt; a[j + 1]) &#123;                int temp;                temp = a[j];                a[j] = a[j + 1];                a[j + 1] = temp;            &#125;        &#125;        printf(&quot;第%d次冒泡：&quot;, i + 1);        for (int j = 0; j &lt; 10; ++j) &#123;            printf(&quot;%d &quot;, a[j]);        &#125;        printf(&quot;\\n&quot;);    &#125;    printf(&quot;----------冒 泡 后----------\\n&quot;);    for (int i = 0; i &lt; 10; ++i) &#123;        printf(&quot;%d &quot;, a[i]);    &#125;&#125;\n\n运行结果：\n\n这是很基础的冒泡，但是还有点瑕疵，比如10个数，可能排5次就排好了，但是这个他是一直运行，直到次数用尽，这就会做很多无用功，所以冒泡排序得优化一下\n优化版#include &lt;stdio.h&gt;int main() &#123;    int a[10], t, flag = 1;    for (int i = 0; i &lt; 10; ++i) &#123;        printf(&quot;请输入第%d个数据:&quot;, i + 1);        scanf(&quot;%d&quot;, &amp;a[i]);    &#125;    for (int i = 0; i &lt; 10; ++i) &#123;        printf(&quot;%d &quot;, a[i]);    &#125;    printf(&quot;\\n----------冒 泡 前----------\\n&quot;);    for (int i = 0; i &lt; 10 - 1 &amp;&amp; flag; ++i) &#123;        flag = 0;        for (int j = 0; j &lt; 10 - i - 1; ++j) &#123;            if (a[j] &gt; a[j + 1]) &#123;                t = a[j];                a[j] = a[j + 1];                a[j + 1] = t;                flag = 1;            &#125;        &#125;                printf(&quot;第%d次冒泡：&quot;, i);        for (int k = 0; k &lt; 10; ++k) &#123;            printf(&quot;%d &quot;, a[k]);        &#125;        printf(&quot;\\n&quot;);    &#125;    printf(&quot;----------冒 泡 后----------\\n&quot;);    for (int i = 0; i &lt; 10; ++i) &#123;        printf(&quot;%d &quot;, a[i]);    &#125;&#125;\n\n运行结果：\n\n这次就是优化后的冒泡排序，比较之前，这次只是冒泡两次就冒泡成功，并停止冒泡，要是按照之前的写，还得进行9次冒泡才行\n选择排序选择排序是一种简单直接的排序算法，思想是先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。\n再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾\n动图演示\n\n代码#include &lt;stdio.h&gt;int main() &#123;    int a[10];    for (int i = 0; i &lt; 10; ++i) &#123;        printf(&quot;请输入第%d个元素数据:&quot;, i + 1);        scanf(&quot;%d&quot;, &amp;a[i]);    &#125;    for (int i = 0; i &lt; 10; ++i) &#123;        printf(&quot;%d &quot;, a[i]);    &#125;    printf(&quot;\\n----------排 序 前----------\\n&quot;);    for (int i = 0; i &lt; 10 - 1; ++i) &#123;        for (int j = i + 1; j &lt; 10; ++j) &#123;            if (a[i] &gt; a[j]) &#123;                int temp;                temp = a[j];                a[j] = a[i];                a[i] = temp;            &#125;        &#125;        printf(&quot;第%d次排序：&quot;, i);        for (int j = 0; j &lt; 10; ++j) &#123;            printf(&quot;%d &quot;, a[j]);        &#125;        printf(&quot;\\n&quot;);    &#125;    printf(&quot;----------排 序 后----------\\n&quot;);    for (int i = 0; i &lt; 10; ++i) &#123;        printf(&quot;%d &quot;, a[i]);    &#125;&#125;\n\n其运行结果是\n\n但是这还有一种优化方法，就是先假设一个最小数，并把假设的最小数的下标赋值给一个元素，然后用那个最小数的下标进行排序，最后在进行判断，如果最小数的下标不等于赋值给它的值的下标，那么就进行交换\n优化版#include &lt;stdio.h&gt;int main() &#123;    int a[10], t, minIdx;    for (int i = 0; i &lt; 10; ++i) &#123;        printf(&quot;请输入第%d个数据:&quot;, i + 1);        scanf(&quot;%d&quot;, &amp;a[i]);    &#125;    for (int i = 0; i &lt; 10; ++i) &#123;        printf(&quot;%d &quot;, a[i]);    &#125;    printf(&quot;\\n----------排 序 前----------\\n&quot;);    for (int i = 0; i &lt; 10 - 1; ++i) &#123;        minIdx = i;        for (int j = i + 1; j &lt; 10; ++j) &#123;            if (a[minIdx] &gt; a[j]) &#123;                minIdx = j;            &#125;        &#125;        if (minIdx != i) &#123;            t = a[i];            a[i] = a[minIdx];            a[minIdx] = t;        &#125;        printf(&quot;第%d次排序：&quot;, i);        for (int k = 0; k &lt; 10; ++k) &#123;            printf(&quot;%d &quot;, a[k]);        &#125;        printf(&quot;\\n&quot;);    &#125;    printf(&quot;----------排 序 后----------\\n&quot;);    for (int i = 0; i &lt; 10; ++i) &#123;        printf(&quot;%d &quot;, a[i]);    &#125;&#125;\n\n其运行结果是\n\n插入排序插入排序，特点是从左往右开始排序\n第一次排序：第一个不动，从第二个开始，跟第一个比较如果第二个比第一个小（从大到小），那么就进行交换，然后第一次排序结束\n第二次排序：从第三个开始跟第二个比较如果第三个小那么什么都不做，第二次排序结束，如果比第二个大，那么就和第二个进行交换，然后交换过后的第二个（原来的第三个）跟第一个比较，大则交换，否则排序结束\n后面的排序都是如此\n\n\n\n\n时间复杂度\n空间复杂度\n是否稳定\n\n\n\nO(n^2)\nO(1)\n稳定\n\n\n代码#include &lt;stdio.h&gt;int main() &#123;    int a[15] = &#123;47, 4, 68, 61, 6, 87, 6, 37, 5, 86, 7, 61, 11, 65, 46&#125;, j;    for (int i = 1; i &lt; 15; ++i) &#123;        int current = a[i];        for (j = i - 1; j &gt;= 0 &amp;&amp; current &lt; a[j]; j--) &#123;            a[j + 1] = a[j];        &#125;            a[j + 1] = current;        printf(&quot;第%d次的排序结果:&quot;, i);        for (int k = 0; k &lt; 15; ++k) &#123;            printf(&quot;%d &quot;, a[k]);        &#125;        printf(&quot;\\n&quot;);    &#125;&#125;\n\n\n\n希尔排序希尔排序的本质其实还是插入排序，不过不再是顺序的从左到右依次排列，而是先进行分组，然后取每组的第一个数进行比较并交换，比较完成之后进行第二组比较，然后是第三组（这里比较几次取决于你定义了几个组），最后一组一定是 1\n\n\n\n\n时间复杂度\n空间复杂度\n是否稳定\n\n\n\nO(n^1.3)\nO(1)\n不稳定\n\n\n代码#include &lt;stdio.h&gt;int main() &#123;    int a[10] = &#123;0, 1, 4, 7, 8, 5, 2, 3, 6, 9&#125;;    int b[3] = &#123;5, 3, 1&#125;;  // 分三组    int len = sizeof(a) / sizeof(int);    for (int x = 0; x &lt; 3; ++x) &#123;        int idx = b[x];        for (int i = idx; i &lt; len; ++i) &#123;            int prive = a[i], j;            for (j = i - idx; j &gt;= 0 &amp;&amp; prive &lt; a[j]; j = j - idx) &#123;                a[j + idx] = a[j];            &#125;            a[j + idx] = prive;        &#125;    &#125;    for (int i = 0; i &lt; 10; ++i) &#123;        printf(&quot;%d &quot;, a[i]);    &#125;&#125;\n\n\n\n快速排序快速排序思想是先通过一次排序找到一个基准值，此时通过排序找到的基准值左边都是比基准值小的数右边都是比基准值大的数，然后先对左边的数进行排序，还是一样，先找个基准值然后跟前面的一样，左边的都是比基准值小的右边都是比基准值大的这样还是对左边进行排序直至有序为止，然后开始对右边的内容进行分排序\n\n\n\n\n时间复杂度\n空间复杂度\n是否稳定\n\n\n\nO(n^1.3)\nO(1)\n不稳定\n\n\n代码#include &lt;stdio.h&gt;void fun(int a[], int low, int high);int kp(int a[], int low, int high);int main() &#123;    int a[10] = &#123;0, 1, 4, 7, 8, 5, 2, 3, 6, 9&#125;;    int len = sizeof(a) / sizeof(int);    fun(a, 0, len - 1);    for (int i = 0; i &lt; 10; ++i) &#123;        printf(&quot;%d &quot;, a[i]);    &#125;&#125;void fun(int a[], int low, int high) &#123;    if (low &lt; high) &#123;        int mid = kp(a, low, high);        fun(a, low, mid - 1);        fun(a, mid + 1, high);    &#125;&#125;int kp(int a[], int low, int high) &#123;    int pivot = a[low];    int i = low;    int j = high;    while (i &lt; j) &#123;        while (i &lt; j &amp;&amp; pivot &lt;= a[j]) j--;        a[i] = a[j];        while (i &lt; j &amp;&amp; pivot &gt;= a[i]) i++;        a[j] = a[i];    &#125;    a[i] = pivot;    return i;&#125;\n\n\n\n查找算法顺序查找从头到尾或者从未到头进行遍历，找到既终止遍历\n\n\n\n查找算法\n时间复杂度\n空间复杂度\n\n\n\n顺序查找\nO(n)\nO(1)\n\n\n代码#include &lt;stdio.h&gt;int cz(int a[]);int main() &#123;    int a[10] = &#123;2, 5, 6, 8, 9, 1, 0, 3, 7, 4&#125;;    int k = cz(a);    if (k == -1) &#123;        printf(&quot;没找到&quot;);    &#125; else &#123;        printf(&quot;下标为%d&quot;, k);    &#125;&#125;int cz(int a[]) &#123;    int b;    printf(&quot;请输入要查找的数:&quot;);    scanf(&quot;%d&quot;, &amp;b);    for (int i = 0; i &lt; 10; ++i) &#123;        if (a[i] == b) &#123;            return i;        &#125;    &#125;    return -1;&#125;\n\n折半查找（二分查找）从中间一分为二，利用中间值的大小判断要找的元素在哪一边，然后继续折半，重复上述过程直至找到目标为止\n\n要查找的数必须是有序的,无序的无法使用折半查找\n\n\n\n\n查找算法\n时间复杂度\n空间复杂度\n\n\n\n折半查找\nO(log2^n)\nO(1)\n\n\n代码#include &lt;stdio.h&gt;int main() &#123;    int a[10] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;    int num, low = 0, high = sizeof(a) / sizeof(int);    scanf(&quot;%d&quot;, &amp;num);    while (low &lt;= high) &#123;        int mid = (low + high) / 2;        if (a[mid] == num) &#123;            printf(&quot;找到了&quot;);            break;        &#125; else if (num &lt; a[mid]) &#123;            high = mid - 1;        &#125; else &#123;            low = mid + 1;        &#125;    &#125;    if (low &gt; high) &#123;        printf(&quot;查找失败&quot;);    &#125;&#125;\n\n代码（递归）#include &lt;stdio.h&gt;int fun(int a[], int num, int low, int high);int main() &#123;    int a[5] = &#123;68, 79, 81, 87, 99&#125;;    int num = 99; // 要查找的数    int low = 0;    int high = sizeof(a) / sizeof(int);    printf(&quot;%d&quot;, fun(a, num, low, high));&#125;int fun(int a[], int num, int low, int high) &#123;    int idx = (low + high) / 2;    int sum = -1;    if (low &lt;= high) &#123;        if (a[idx] == num) &#123;            return idx;        &#125; else if (a[idx] &lt; num) &#123;            sum = fun(a, num, low + 1, high);        &#125; else &#123;            sum = fun(a, num, low, high - 1);        &#125;    &#125;    if (a[sum] == num) &#123;        return sum;    &#125; else &#123;        return -1;    &#125;&#125;\n\n分块查找数据要有一定的顺序，要把一整个数组分成若干个块，而且块与块之间有顺序，分块里面的值不能超过设置的块值，如一下案例，数组共有十五个，分三块，第一个块值为 5 那么块里面的值不能超过 5\n\n\n\n查找算法\n时间复杂度\n空间复杂度\n\n\n\n分块查找\nO(log2^n)~O(n)\nO(1)\n\n\n代码#include &lt;stdio.h&gt;int main() &#123;    int a[15] = &#123;5, 4, 3, 2, 1, 6, 7, 8, 9, 10, 15, 14, 13, 12, 11&#125;;    int b[3] = &#123;5, 10, 15&#125;;    int sum;    printf(&quot;请输入要查找的数:&quot;);    scanf(&quot;%d&quot;, &amp;sum);    int i, j;    for (i = 0; i &lt; 3; ++i) &#123;        if (sum &lt;= b[i]) &#123;            break;        &#125;    &#125;    if (i == 3) &#123;        printf(&quot;数太大&quot;);    &#125; else &#123;        int idx = 5 * i;        for (j = idx; j &lt; idx + 5; ++j) &#123;            if (a[j] == sum) &#123;                printf(&quot;找到了&quot;);                break;            &#125;        &#125;        if (j == idx + 5) &#123;            printf(&quot;没找到&quot;);        &#125;    &#125;&#125;\n\n算法总结\n算法的五大特征\n​\t\t有穷性、确定性、可行性、输入项、输出项\n\n算法的四个目标\n​\t\t正确性、健壮性、可读性、高效性\n\n时间复杂度 : O( )\n​\t\t用来描述算法的运行时间\n​\t\tO(1) &lt; O(logn) &lt; O(n) &lt; O(n ^ 2) &lt; O(n ^ 3)\n\n空间复杂度 : O( )\n​\t\t用来描述算法所耗费的存储空间\n\n\n排序\n\n\n排序方法\n时间复杂度\n空间复杂度\n是否稳定\n\n\n\n冒泡排序\nO(n^2)\nO(1)\n稳定\n\n\n选择排序\nO(n^2)\nO(1)\n不稳定\n\n\n插入排序\nO(n^2)\nO(1)\n稳定\n\n\n希尔排序\nO(n^1.3)\nO(1)\n不稳定\n\n\n快速排序\nO(nlog2^n)\nO(n)\n不稳定\n\n\n\n如果待排序序列中两个数据元素具有相同的值，在排序前后它们的相互位置发生颠倒，则称该排序算法是不稳定的\n用某排序方法对一个关键码序列进行递增排序时，对于其中关键码相同的元素，若该方法可保证在排序前后这些元素的相对位置不变，则称该排序方法是稳定的\n\n\n冒泡排序：每次把最大的或者最小的数据排出来\n选择排序：每次从数据中找到最大的或者最小的，将其放到前面的位置\n插入排序：从下标为1的数据开始；把后面的数与前面的进行比较找到合适的位置插入进去\n希尔排序：增量数组递减d[]，d[k]个数组为一组，每组的第一个数据进行插入排序\n快速排序：假设第一个数是基准值，将所有小于基准值的数放到基准值之前；大于基准值的数放到基准值之后\n\n查找\n\n\n查找算法\n时间复杂度\n空间复杂度\n\n\n\n顺序查找\nO(n)\nO(1)\n\n\n折半查找\nO(log2^n)\nO(1)\n\n\n分块查找\nO(log2^n)~O(n)\nO(1)\n\n\n\n顺序查找：在数组中，从第一个往后面挨个对比\n折半查找：从数组的中间开始对比，数小于待查找的，查后半部分；数大于待查找，查前半部分； 前提：数组有序，或从小到大，或从大到小\n分块查找：把数组分为若干个元素个数相同的块，且块间有序；首先找到块号，从块号里面进行顺序查找\n\n","tags":["代码","算法","C语言"]},{"title":"CPU流泪器","url":"/2023/03/21/%E9%9A%8F%E8%AE%B0/CPU%E6%B5%81%E6%B3%AA%E5%99%A8/","content":"前言有一天，在我在虚拟机上玩病毒的时候突发奇想，我也要搞一个类似的玩意儿耍耍（当然，肯定不是搞那种破坏计算机的病毒）\n我就想了想病毒运行时候在电脑上所做的操作，其他的不管，就说满屏的文件夹和数不尽的弹窗\n诶嘿~ 没错，这次搞的就是满屏幕的文件夹和数不尽的弹窗，不会对计算机造成伤害也能让自己快乐起来\n\n这个方法可能在Win11系统上不会出现文件夹，但是会出现一堆的错误提示，关一个马上跳出来另一个\n\n方法这个是通过批处理（bat）文件来进行操作的，所以要有一个批处理的文件\n\n创建文件：说来也简单，就是创建一个.txt文档，然后把后缀名改成 bat就行了\n\n然后在文件内写入一端代码\n@echo offfor /l %%a in (0,1,10) do (\tmd .\\%%a\tstart &quot;&quot; &quot;.\\%%a&quot;)exit\n\n别看这代码少，所谓浓缩的都是精华，虽然少但是威力不小（足以让你的CPU非常难受）\n这段代码的意思就是创建一个for循环从0开始循环1000次，然后每次循环都会干一件事情，就是在本目录创建从0开始到1000为止的文件夹，同时创建完成之后打开该文件夹\n听着或许就那样，但是同时打开1000个文件夹你就说你的电脑撑得住不撑得住\n在桌面上打开的话会出现一个屏幕都是文件夹，怎么样，是不是有那味儿了，这个1000也是可以改的就是那个括号里面第三个数，改成多少次，就创建多少个文件夹，并出现弹窗多少次\n那么多弹窗如果只有十个还好但是要是跟现在一样1000多个一个一个关不现实所以可以通过任务管理器进行全部关闭（如果你能打开的话），快捷键是（Ctrl+shift+ESC），也可右键任务栏点击任务管理器也行，然后在管理器里面找到并右键 Windows 资源管理器，然后点击重新启动就OK了\nWin11专属@echo offsetlocalset uac=~uac_permission_tmp_%random%md &quot;%SystemRoot%\\system32\\%uac%&quot; 2&gt;nulif %errorlevel%==0 ( rd &quot;%SystemRoot%\\system32\\%uac%&quot; &gt;nul 2&gt;nul ) else (    echo set uac = CreateObject^(&quot;Shell.Application&quot;^)&gt;&quot;%temp%\\%uac%.vbs&quot;    echo uac.ShellExecute &quot;%~s0&quot;,&quot;&quot;,&quot;&quot;,&quot;runas&quot;,1 &gt;&gt;&quot;%temp%\\%uac%.vbs&quot;    echo WScript.Quit &gt;&gt;&quot;%temp%\\%uac%.vbs&quot;    &quot;%temp%\\%uac%.vbs&quot; /f    del /f /q &quot;%temp%\\%uac%.vbs&quot; &amp; exit )endlocalfor /l %%a in (0,1,1) do ( md .\\%%a start &quot;&quot; &quot;.\\%%a&quot;)exit\n\n专门为Win11而设计，这跟上面的区别是多了从 3 到 12 行的代码，这段代码是用来获取管理员权限的，当然还得让人家同意才行，不过也够了，解决了Win11的失效问题\n\n注意：强烈建议不要在自己电脑上尝试，这将是一个非常难受的行为\n\n","categories":["随记"],"tags":["脚本","bat"]},{"title":"Edge游览器扩展报错","url":"/2022/07/10/%E9%9A%8F%E8%AE%B0/Edge%E6%B8%B8%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95%E6%8A%A5%E9%94%99/","content":"前言某一天我心血来潮想下载某个扩展但是一直在转圈圈，这还不算，转完之后给我报错(Download interrupted)\n难受ing~\n当时还以为是网络的问题…说多了都是泪,接下来说解决方法\n解决方法\n打开C盘的这个（C:\\Windows\\System32\\drivers\\etc）地址\n\n找到其中的hosts文件,并以 文本编辑程序(记事本) 打开，并在hosts文件中写入以下内容，然后保存，就不会报错了\n\n131.253.33.219 edge.microsoft.com\n131.253.33.219 msedgeextensions.sf.tlu.dl.delivery.mp.microsoft.com\n\n\n\n\n无法保存如果保存的时候限制管理员身份，保存不了的话，可以通过以下方法来保存\n\n先打开hosts文件，然后复制(Ctrl+c)该文件，到桌面(随便什么地方)粘贴(Ctrl+v)文件\n打开文件并复制粘贴方法一需要写入的文本，然后保存\n再打开hosts文件的路径并把已经写完文本(桌面中)的hosts文件拖动到改路径，直接点击替换目标中的文件如下图\n\n\n","categories":["随记"],"tags":["游览器","报错解决方法"]},{"title":"OneDriver直链","url":"/2023/02/05/%E9%9A%8F%E8%AE%B0/OneDriver%E7%9B%B4%E9%93%BE/","content":"前言OneDriver都知道，是微软旗下的一款网盘，平常只能用来存东西用，但是他还能不一样一点，转换成直链，当成图床视频床使用\nOneDriver直链转换原链接：\n\nhttps://前缀-my.sharepoint.com/:字母:/g/personal/账户名/文件地址\n\n三种直链方式\nhttps://前缀-my.sharepoint.com/personal/账户名/Documents/文件地址（带后缀）\n\n这种方式有一个坏处就是只要你的文件移动了位置，比如把图片A从文件夹B移动到文件夹C里面的话，要是还是用之前文件还在文件夹A里面的时候的链接的话，那么地址就会失效，而且也有可能要查看文件时得登录才能查看\n简单来说，就是用此链接之后，就不能轻易改动文件位置，否则就会导致文件失效\n\nhttps://前缀-my.sharepoint.com/personal/账户名/_layouts/52/download.aspx?share=分享链接（就是账户名之后的一段字符串）\n\n这一种比上面的更好一点，至少更改图片位置不会影响链接\n\nhttps://前缀-my.sharepoint.com/:字母:/g/personal/账户名/分享链接?download=1\n\n重定向跳转至链接\nC语言链接替换脚本\n仅对文件可用，文件夹使用则失效\n\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;//获取前缀void qianzhui(char yuan_lian[], char qian_zhui[]);//获取账户void zhanghu(char yuan_lian[], char zhang_hu[]);//获取地址void dizhi(char yuan_lian[], char di_zhi[]);int main() &#123;    while (1) &#123;        //进行原链接输入        char yuan_lian[300];        printf(&quot;请输入原链接：&quot;);        gets(yuan_lian);        printf(&quot;\\n&quot;);        //进行转直链        //前缀        char qian_zhui[10];        qianzhui(yuan_lian, qian_zhui);        //用户名        char zhang_hu[100];        zhanghu(yuan_lian, zhang_hu);        //链接        char di_zhi[100];        dizhi(yuan_lian, di_zhi);        //直链输出        printf(&quot;直链：https://%s-my.sharepoint.com/personal/%s/_layouts/52/download.aspx?share=%s\\n\\n&quot;, qian_zhui,               zhang_hu, di_zhi);    &#125;&#125;//获取地址void dizhi(char yuan_lian[], char di_zhi[]) &#123;    //被判断的字符串    char temp[] = &quot;_com/&quot;;    //字符串的个数    int num = sizeof(temp) / sizeof(char);    //要判断的字符串    char temp_2[num];    //循环到账户名前一个    int i = 0, d, j;    while (yuan_lian[i] != &#x27;\\0&#x27;) &#123;        d = i;        for (j = 0; j &lt; num - 1; ++j) &#123;            temp_2[j] = yuan_lian[d];            d++;        &#125;        temp_2[j] = &#x27;\\0&#x27;;        if (strcmp(temp_2, temp) == 0) &#123;            break;        &#125;        i++;    &#125;    //进行账户名提取    int q = 0;    while (yuan_lian[d] != &#x27;\\0&#x27;) &#123;        di_zhi[q] = yuan_lian[d];        d++;        q++;    &#125;    di_zhi[q] = &#x27;\\0&#x27;;&#125;//获取账户名void zhanghu(char yuan_lian[], char zhang_hu[]) &#123;    //被判断的字符串    char temp[] = &quot;personal/&quot;;    //字符串的个数    int num = sizeof(temp) / sizeof(char);    //要判断的字符串    char temp_2[num];    //循环到账户名前一个    int i = 0, d, j;    while (yuan_lian[i] != &#x27;\\0&#x27;) &#123;        d = i;        for (j = 0; j &lt; num - 1; ++j) &#123;            temp_2[j] = yuan_lian[d];            d++;        &#125;        temp_2[j] = &#x27;\\0&#x27;;        if (strcmp(temp_2, temp) == 0) &#123;            break;        &#125;        i++;    &#125;    //进行账户名提取    int q = 0;    while (yuan_lian[d] != &#x27;/&#x27;) &#123;        zhang_hu[q] = yuan_lian[d];        d++;        q++;    &#125;    zhang_hu[q] = &#x27;\\0&#x27;;&#125;void qianzhui(char yuan_lian[], char qian_zhui[]) &#123;    //temp为临时值，用于判断    int i = 0;    char temp = yuan_lian[0];    //循环至前缀位置    while (yuan_lian[i] != &#x27;\\0&#x27;) &#123;        temp = yuan_lian[i];        i++;        if (temp == &#x27;/&#x27; &amp;&amp; yuan_lian[i] == &#x27;/&#x27;) &#123;            break;        &#125;    &#125;    i++;    //提取前缀    int j = 0;    while (yuan_lian[i] != &#x27;-&#x27;) &#123;        qian_zhui[j++] = yuan_lian[i];        i++;    &#125;    qian_zhui[j] = &#x27;\\0&#x27;;&#125;\n\n下载编译好的文件：点击下载\n","categories":["随记"],"tags":["代码","脚本","链接","网盘"]},{"title":"Typora图片上传","url":"/2023/01/04/%E9%9A%8F%E8%AE%B0/Typora%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/","content":"前言在写md笔记的时，有点时候就得把文件分享给他人，没图片还好，有图片的话还得把图片一起分享过去，这样显得很麻烦也很呆\n有那么一种办法，让文件带着图片远走高飞\nGitHub图床\n平民的不二选择，除了访问慢一点其他一切都好（免费还要啥自行车）\n保证浏览器访问要用图床，保证加载速度要用图床工具，又不花钱想想就开心\nGitHub图床搭建说的那么高深其实就是在GitHub中新建一个仓库，然后将图片存放在新建的仓库中\n在GitHub主页的左上角有个如下图的按钮\n\n点New创建仓库；具体步骤如下所示\n\n创建好的仓库\n\n在Markdown中使用图床不管你是git或拖拽只要把图片导入到仓库就可以使用图床中的图片了\nGitHub上传文件的两种状态\n\n在Markdown中引用图片按照如下格式引用到Markdown文件中\n![](https://cdn.jsdelivr.net/gh/GitHub名称/仓库名/图片名.后缀)\n\n图片就显示出来了\n使用jsDelivr加速建好了图床可以在浏览器中访问了，这样就够了吗？\n想想平时访问GitHub的速度，还可能把特别大的图片放在仓库中，加载速度属实急人啊！\n不过幸好，jsDelivr帮你解决了这个问题！\n\n按照模板直接套\n\n仓库中的文件无论什么格式都可以这样加速（上面是常用的一种方法，想具体了解可以看官方文档）\nTypora搭配PicGo使用PicGo可以使用除git和拖拽以外的第三种方法向图床传送文件，还支持自动复制链接等功能\n\nPicGo下载地址： https://github.com/Molunerfinn/PicGo/releases\n\n配置Typora打开Typora -&gt; 文件 -&gt; 偏好设置 -&gt; 图像\n\n配置PicGo在Github上面生成token\n\n设置PicGo\n\n点击设置 -&gt; 设置Server -&gt; 设置监听端口（设置为36677）\n全部设置完成之后，点击确定并设置为默认图床\n模板：https://cdn.jsdelivr.net/gh/GitHub用户名/图床仓库名\n这样就完成了，用的时候直接复制图片到Typora就会自动上传\n错误图片不显示图片不显示这个原因可能是GitHub的问题\nGitHub的图片被保存到了：https://raw.githubusercontent.com\n但是这个地址好像被墙了，这就导致会无法访问图片\n解决方法就是更改hosts文件\n\n打开域名解析网站：https://ping.eu/nslookup\n\n然后输入 raw.githubusercontent.com，如下图\n\n\n\n打开本机的 hosts 文件，路径：C:\\Windows\\System32\\drivers\\etc\\hosts 然后添加如下内容(上图红框中的地址)\n\n\n\n刷新本机DNS解析\n\nWin+R，输入cmd打开黑窗口，输入ipconfig &#x2F;flushdns刷新一下本机的DNS解析\n\n\n\n\n","categories":["随记"],"tags":["小知识","工具"]},{"title":"Rewards刷积分脚本","url":"/2023/02/16/%E9%9A%8F%E8%AE%B0/Rewards%E5%88%B7%E7%A7%AF%E5%88%86%E8%84%9A%E6%9C%AC/","content":"快速获取 Rewards 积分Rewards 是微软为了宣传自家游览器退出的一项计划，里面可以用积分兑换很多东西，最中意的就是京东的50元的现金券，还有100元的，但是不是每天都有问题需要进行搜索，所以，通过脚本搜索来进行获取积分\n脚本是通过C语言来进行编写\n脚本是通过40次不重复搜索内容进行搜索来达到快速获取积分\n当然，次数也可以自己增加，具体视情况而定\n操作脚本的执行时间大约是5分钟\n第三版 - 最新之前的代码进行搜索的时候不是很稳定，对手机端搜索时要打开游览器的仿真设备这点可以参照第二版进行设置，这次对搜索和代码都做了以下几点的优化\n搜索手机上的搜索不在进行简单的ABC搜索的换成了洪荒的人物和法宝\n代码对代码进行了瘦身不再是那么臃肿，这次的代码可以更好的进行知道了要搜索哪些东西\n搜索方式也由原来的模仿键盘的按下弹起换成先把搜索词复制到剪切板里面然后进行ctrl+v进行搜索，比之前稳定了不少\n这次直接把编译好的放在下面点我前往；本次编译好的一共四个版本\n\n第一个版本：可以有控制台，输入数字从而确定刷取那个端的积分，也可以一起刷\n第二个版本：跟第一版的一样，不过没有了控制台，直接进行全端搜索\n第三个版本：只搜索电脑端\n第四个版本：只搜索移动端\n\n根据自己的情况进行下载即可，第三版的源码就是第二个版本的源码，其他的版本是在第二版上稍作修改\n这个版本搜索次数从10次关改成了5次关\n注意事项—非常重要！！！\n这里有几个小前置条件一定要完成，不然会导致手机端积分无法刷取（以下做的所有操作都是在Edge游览器里面）\n\n\n一定要将游览器窗口最大化（这里是因为脚本会吧鼠标指针放到搜索框部分所以要最大化）\n看看自己的F12是否管用（就是点击F12会出现前端代码页面的部分如果不能前往设置里面在系统和性能一栏里面的最下面找到并打开使用 F12 键打开开发人员工具）\n一定要开启仿真设备具体开启方法可以在废弃的第二版里面找到\n\n第二版- 废弃之前的代码只能是进行电脑端的积分刷取，这就导致手机上的60积分刷不到，每天都导致有60的积分从我手中溜走，很是难受\n但是这次加强版来了~\n这次在原有的基础上（1~174）的上面增加了代码，这次要刷取的手机端还要有几个条件，务必做到！！！没有做到就代表无法刷取成功\n\n打开游览器上面的开发人员模式（F12），按键盘上的F12即可打开之后可以看到H5的代码显示框左上角有两个按钮，点击右边的切换仿真设备\n !\n\n选择图片图片中打对钩的，或者随便一个应该也可以\n\n记住一定要选不然无法刷取手机端积分\n\n\n\n\n这次利用的原理就是，微软的bing引擎在电脑上点击F12并切换到仿真设备就可实现搜索手机端的积分也会增加\n说明 - 废弃解答代码语义\n\nSetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);\nprintf(“执行第%d次\\n”, i);\nsystem(“start https://cn.bing.com/search?q=曦暮流年“);\nSleep(1500);\nsystem(“taskkill &#x2F;f &#x2F;im msedge.exe”);\n\n第一行是进行窗口置顶\n第二行是给出已经执行了几次的代码\n第三行是进行bing搜索，当然 q&#x3D; 后面的文字也是可以改的，改成什么，就搜索什么，不过没必要，只是单纯刷积分而已\n第四行是进行延迟搜索，也就是搜索中间有时间间隔，这一步是为了防止搜索过快不给你记录积分也防止网页还没有成功搜索就被关闭\n第五行是进行关闭游览器，我设置的是搜索够10个就关闭一下游览器\n源码第三版 - 半自动搜索 - 最新\n下载第一版源码\n\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;windows.h&gt;void PC();void YD();void TC();int main() &#123;    HWND hWnd = GetForegroundWindow();    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    system(&quot;mode con cols=50 lines=25&quot;);    system(&quot;title 曦暮流年 - Rewards 积分刷取&quot;);    while (1) &#123;        printf(&quot;\\t##########################\\n&quot;);        printf(&quot;\\t#                        #\\n&quot;);        printf(&quot;\\t#      曦 暮 流 年       #\\n&quot;);        printf(&quot;\\t#    Rewards 积分刷取    #\\n&quot;);        printf(&quot;\\t#                        #\\n&quot;);        printf(&quot;\\t##########################\\n\\n\\n&quot;);        printf(&quot;\\t1. 全端一起刷\\n&quot;);        printf(&quot;\\t2. 刷电脑端\\n&quot;);        printf(&quot;\\t3. 刷移动端\\n&quot;);        printf(&quot;\\t0. 退出\\n\\n&quot;);        printf(&quot;\\t刷取完之后会自动退出\\n&quot;);        printf(&quot;\\t刷取移动端时需要开启仿真设备\\n&quot;);        printf(&quot;\\t详情请前往www.ximuliunian.top\\n\\n&quot;);        int a;        printf(&quot;\\t请输入数字编号：&quot;);        scanf(&quot;%d&quot;, &amp;a);        switch (a) &#123;            case 1:                PC();                YD();                TC();                return 0;            case 2:                PC();                TC();                return 0;            case 3:                YD();                TC();                return 0;            case 0:                printf(&quot;感谢使用 再见！&quot;);                Sleep(2000);                exit(0);            default:                system(&quot;CLS&quot;);                printf(&quot;输入的不是应有的编号哦~~~\\n&quot;);                printf(&quot;请重新输入\\n\\n&quot;);        &#125;    &#125;&#125;void PC() &#123;    char gjz_1[40][20] = &#123;            &quot;行宫&quot;, &quot;登鹳雀楼&quot;, &quot;新嫁娘词&quot;, &quot;白居易&quot;, &quot;岑参&quot;, &quot;常建&quot;, &quot;陈陶&quot;, &quot;陈子昂&quot;, &quot;崔颢&quot;, &quot;崔曙&quot;,            &quot;崔涂&quot;, &quot;戴叔伦&quot;, &quot;杜甫&quot;, &quot;杜牧&quot;, &quot;杜审言&quot;, &quot;杜荀鹤&quot;, &quot;高适&quot;, &quot;顾况&quot;, &quot;韩翃&quot;, &quot;韩偓&quot;,            &quot;韩愈&quot;, &quot;贺知章&quot;, &quot;皇甫冉&quot;, &quot;贾岛&quot;, &quot;金昌绪&quot;, &quot;李白&quot;, &quot;李端&quot;, &quot;李频&quot;, &quot;李颀&quot;, &quot;李商隐&quot;,            &quot;李益&quot;, &quot;刘长卿&quot;, &quot;刘方平&quot;, &quot;刘昚虚&quot;, &quot;刘禹锡&quot;, &quot;柳中庸&quot;, &quot;柳宗元&quot;, &quot;卢纶&quot;, &quot;骆宾王&quot;, &quot;马戴&quot;    &#125;;    int i;    for (i = 0; i &lt; 40; i++) &#123;        char wz[] = &quot;start https://cn.bing.com/search?q=&quot;;        printf(&quot;电脑端 - 执行第%d次\\n&quot;, i + 1);        system(strcat(wz, gjz_1[i]));        Sleep(2000);        if ((i + 1) % 5 == 0) &#123;            Sleep(1000);            system(&quot;taskkill /f /im msedge.exe&quot;);            printf(&quot;\\n\\n&quot;);        &#125;    &#125;    system(&quot;taskkill /f /im msedge.exe&quot;);&#125;void YD() &#123;    char gjz_2[30][20] = &#123;            &quot;曦暮流年&quot;, &quot;三皇五帝&quot;, &quot;伏羲&quot;, &quot;神农&quot;, &quot;黄帝&quot;, &quot;颛顼&quot;, &quot;帝喾&quot;, &quot;唐尧&quot;, &quot;虞舜&quot;, &quot;天帝&quot;,            &quot;轩辕剑&quot;, &quot;东皇钟&quot;, &quot;盘古斧&quot;, &quot;炼妖壶&quot;, &quot;射日弓&quot;, &quot;伏羲琴&quot;, &quot;补天石&quot;, &quot;崆峒印&quot;, &quot;昆仑镜&quot;, &quot;女娲石&quot;,            &quot;开天斧&quot;, &quot;山河社稷图&quot;, &quot;玲珑塔&quot;, &quot;混沌珠&quot;, &quot;乾坤袋&quot;, &quot;封天印&quot;, &quot;太极图&quot;, &quot;盘古幡&quot;, &quot;诛仙剑阵&quot;, &quot;先天五行旗&quot;    &#125;;    int j;    for (j = 0; j &lt; 30; j++) &#123;                printf(&quot;手机端 - 执行第%d次\\n&quot;, j + 1);        ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);        Sleep(1000);        keybd_event(VK_F12, 0, 0, 0);        keybd_event(VK_F12, 0, 2, 0);        Sleep(3000);        SetCursorPos(300, 50);        mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);        mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);        Sleep(2000);        char echo[] = &quot;echo &quot;;        char clip[] = &quot; | clip&quot;;        system(strcat(strcat(echo, gjz_2[j]), clip));        keybd_event(VK_CONTROL, 0, 0, 0);        keybd_event(&#x27;V&#x27;, 0, 0, 0);        keybd_event(&#x27;V&#x27;, 0, 2, 0);        keybd_event(VK_CONTROL, 0, 2, 0);        Sleep(1000);        keybd_event(VK_RETURN, 0, 0, 0);        keybd_event(VK_RETURN, 0, 2, 0);        Sleep(2000);        if ((j + 1) % 5 == 0) &#123;            Sleep(1000);            system(&quot;taskkill /f /im msedge.exe&quot;);            printf(&quot;\\n\\n&quot;);        &#125;    &#125;    system(&quot;taskkill /f /im msedge.exe&quot;);&#125;void TC() &#123;    system(&quot;CLS&quot;);    printf(&quot;执行完成，感谢使用，再见！&quot;);    Sleep(2000);&#125;\n\n\n\n第三版 - 自动搜索 - 最新\n下载第二版源码\n\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;windows.h&gt;int main() &#123;    HWND hWnd = GetForegroundWindow();    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    system(&quot;mode con cols=50 lines=25&quot;);    system(&quot;title 曦暮流年 - Rewards 积分刷取&quot;);    char gjz_1[40][20] = &#123;            &quot;行宫&quot;, &quot;登鹳雀楼&quot;, &quot;新嫁娘词&quot;, &quot;白居易&quot;, &quot;岑参&quot;, &quot;常建&quot;, &quot;陈陶&quot;, &quot;陈子昂&quot;, &quot;崔颢&quot;, &quot;崔曙&quot;,            &quot;崔涂&quot;, &quot;戴叔伦&quot;, &quot;杜甫&quot;, &quot;杜牧&quot;, &quot;杜审言&quot;, &quot;杜荀鹤&quot;, &quot;高适&quot;, &quot;顾况&quot;, &quot;韩翃&quot;, &quot;韩偓&quot;,            &quot;韩愈&quot;, &quot;贺知章&quot;, &quot;皇甫冉&quot;, &quot;贾岛&quot;, &quot;金昌绪&quot;, &quot;李白&quot;, &quot;李端&quot;, &quot;李频&quot;, &quot;李颀&quot;, &quot;李商隐&quot;,            &quot;李益&quot;, &quot;刘长卿&quot;, &quot;刘方平&quot;, &quot;刘昚虚&quot;, &quot;刘禹锡&quot;, &quot;柳中庸&quot;, &quot;柳宗元&quot;, &quot;卢纶&quot;, &quot;骆宾王&quot;, &quot;马戴&quot;    &#125;;    int i;    for (i = 0; i &lt; 40; i++) &#123;        char wz[] = &quot;start https://cn.bing.com/search?q=&quot;;        printf(&quot;电脑端 - 执行第%d次\\n&quot;, i + 1);        system(strcat(wz, gjz_1[i]));        Sleep(2000);                if ((i + 1) % 5 == 0) &#123;            Sleep(1000);            system(&quot;taskkill /f /im msedge.exe&quot;);            printf(&quot;\\n\\n&quot;);        &#125;    &#125;    system(&quot;taskkill /f /im msedge.exe&quot;);    char gjz_2[30][20] = &#123;            &quot;曦暮流年&quot;, &quot;三皇五帝&quot;, &quot;伏羲&quot;, &quot;神农&quot;, &quot;黄帝&quot;, &quot;颛顼&quot;, &quot;帝喾&quot;, &quot;唐尧&quot;, &quot;虞舜&quot;, &quot;天帝&quot;,            &quot;轩辕剑&quot;, &quot;东皇钟&quot;, &quot;盘古斧&quot;, &quot;炼妖壶&quot;, &quot;射日弓&quot;, &quot;伏羲琴&quot;, &quot;补天石&quot;, &quot;崆峒印&quot;, &quot;昆仑镜&quot;, &quot;女娲石&quot;,            &quot;开天斧&quot;, &quot;山河社稷图&quot;, &quot;玲珑塔&quot;, &quot;混沌珠&quot;, &quot;乾坤袋&quot;, &quot;封天印&quot;, &quot;太极图&quot;, &quot;盘古幡&quot;, &quot;诛仙剑阵&quot;, &quot;先天五行旗&quot;    &#125;;    int j;    for (j = 0; j &lt; 30; j++) &#123;        printf(&quot;手机端 - 执行第%d次\\n&quot;, j + 1);        ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);        Sleep(1000);        keybd_event(VK_F12, 0, 0, 0);        keybd_event(VK_F12, 0, 2, 0);        Sleep(3000);        SetCursorPos(300, 50);        mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);        mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);        Sleep(2000);        char echo[] = &quot;echo &quot;;        char clip[] = &quot; | clip&quot;;        system(strcat(strcat(echo, gjz_2[j]), clip));        keybd_event(VK_CONTROL, 0, 0, 0);        keybd_event(&#x27;V&#x27;, 0, 0, 0);        keybd_event(&#x27;V&#x27;, 0, 2, 0);        keybd_event(VK_CONTROL, 0, 2, 0);        Sleep(1000);        keybd_event(VK_RETURN, 0, 0, 0);        keybd_event(VK_RETURN, 0, 2, 0);        Sleep(2000);        if ((j + 1) % 5 == 0) &#123;            Sleep(1000);            system(&quot;taskkill /f /im msedge.exe&quot;);            printf(&quot;\\n\\n&quot;);        &#125;    &#125;    system(&quot;taskkill /f /im msedge.exe&quot;);&#125;\n\n第二版 - 废弃#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;windows.h&gt;int main() &#123;    HWND hWnd = GetForegroundWindow();    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;运行时间约五分种\\n&quot;);    Sleep(1800);    int i = 1;    printf(&quot;第一阶段执行 - 电脑端\\n&quot;);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=行宫&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=登鹳雀楼&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=新嫁娘词&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=白居易&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=岑参&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=常建&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=陈陶&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=陈子昂&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=崔颢&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=崔曙&quot;);    Sleep(1800);    system(&quot;taskkill /f /im msedge.exe&quot;);    printf(&quot;第一阶段结束\\n\\n&quot;);    printf(&quot;第二阶段开始\\n&quot;);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=崔涂&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=戴叔伦&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=杜甫&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=杜牧&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=杜审言&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=杜荀鹤&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=高适&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=顾况&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=韩翃&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=韩偓&quot;);    Sleep(1800);    system(&quot;taskkill /f /im msedge.exe&quot;);    printf(&quot;第二阶段结束\\n\\n&quot;);    printf(&quot;第三阶段开始\\n&quot;);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=韩愈&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=贺知章&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=皇甫冉&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=贾岛&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=金昌绪&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=李白&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=李端&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=李频&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=李颀&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;电脑端 - 执行第%d次\\n&quot;, i);    system(&quot;start https://cn.bing.com/search?q=李商隐&quot;);    Sleep(1800);    system(&quot;taskkill /f /im msedge.exe&quot;);    printf(&quot;第三阶段结束\\n\\n&quot;);    printf(&quot;第四阶段开始\\n&quot;);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=李益&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=刘长卿&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=刘方平&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=刘昚虚&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=刘禹锡&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=柳中庸&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=柳宗元&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=卢纶&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=骆宾王&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i);    system(&quot;start https://cn.bing.com/search?q=马戴&quot;);    Sleep(1200);    system(&quot;taskkill /f /im msedge.exe&quot;);    printf(&quot;第四阶段结束\\n\\n&quot;);    printf(&quot;电脑端 - 执行完成\\n&quot;);    printf(&quot;手机端 - 开始执行\\n&quot;);    i = 1;    Sleep(3000);    printf(&quot;第五阶段开始\\n&quot;);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i++);    keybd_event(VK_CAPITAL, 0, 0, 0);    keybd_event(VK_CAPITAL, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(2000);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(1000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);  //左键松开    Sleep(1000);    keybd_event(&#x27;A&#x27;, 0, 0, 0);    keybd_event(&#x27;A&#x27;, 0, 2, 0);    keybd_event(&#x27;A&#x27;, 0, 0, 0);    keybd_event(&#x27;A&#x27;, 0, 2, 0);    Sleep(2000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(2000);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i++);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(2000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);    keybd_event(&#x27;B&#x27;, 0, 0, 0);    keybd_event(&#x27;B&#x27;, 0, 2, 0);    keybd_event(&#x27;B&#x27;, 0, 0, 0);    keybd_event(&#x27;B&#x27;, 0, 2, 0);    Sleep(1000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(2000);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i++);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(2000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);    keybd_event(&#x27;C&#x27;, 0, 0, 0);    keybd_event(&#x27;C&#x27;, 0, 2, 0);    keybd_event(&#x27;C&#x27;, 0, 0, 0);    keybd_event(&#x27;C&#x27;, 0, 2, 0);    Sleep(1000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(2000);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i++);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(2000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);    keybd_event(&#x27;D&#x27;, 0, 0, 0);    keybd_event(&#x27;D&#x27;, 0, 2, 0);    keybd_event(&#x27;D&#x27;, 0, 0, 0);    keybd_event(&#x27;D&#x27;, 0, 2, 0);    Sleep(1000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(2000);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i++);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(2000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);    keybd_event(&#x27;E&#x27;, 0, 0, 0);    keybd_event(&#x27;E&#x27;, 0, 2, 0);    keybd_event(&#x27;E&#x27;, 0, 0, 0);    keybd_event(&#x27;E&#x27;, 0, 2, 0);    Sleep(1000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(2000);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i++);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(2000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);    keybd_event(&#x27;F&#x27;, 0, 0, 0);    keybd_event(&#x27;F&#x27;, 0, 2, 0);    keybd_event(&#x27;F&#x27;, 0, 0, 0);    keybd_event(&#x27;F&#x27;, 0, 2, 0);    Sleep(1000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(2000);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i++);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(2000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);    keybd_event(&#x27;G&#x27;, 0, 0, 0);    keybd_event(&#x27;G&#x27;, 0, 2, 0);    keybd_event(&#x27;G&#x27;, 0, 0, 0);    keybd_event(&#x27;G&#x27;, 0, 2, 0);    Sleep(1000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(2000);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i++);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(2000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);    keybd_event(&#x27;H&#x27;, 0, 0, 0);    keybd_event(&#x27;H&#x27;, 0, 2, 0);    keybd_event(&#x27;H&#x27;, 0, 0, 0);    keybd_event(&#x27;H&#x27;, 0, 2, 0);    Sleep(1000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(2000);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i++);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(2000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);    keybd_event(&#x27;I&#x27;, 0, 0, 0);    keybd_event(&#x27;I&#x27;, 0, 2, 0);    keybd_event(&#x27;I&#x27;, 0, 0, 0);    keybd_event(&#x27;I&#x27;, 0, 2, 0);    Sleep(1000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(2000);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i++);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(2000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);    keybd_event(&#x27;J&#x27;, 0, 0, 0);    keybd_event(&#x27;J&#x27;, 0, 2, 0);    keybd_event(&#x27;J&#x27;, 0, 0, 0);    keybd_event(&#x27;J&#x27;, 0, 2, 0);    Sleep(1000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    Sleep(2000);    keybd_event(VK_CAPITAL, 0, 0, 0);    keybd_event(VK_CAPITAL, 0, 2, 0);    Sleep(3000);    system(&quot;taskkill /f /im msedge.exe&quot;);    printf(&quot;第五阶段结束\\n\\n&quot;);    printf(&quot;第六阶段开始\\n\\n&quot;);    Sleep(2000);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i++);    keybd_event(VK_CAPITAL, 0, 0, 0);    keybd_event(VK_CAPITAL, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(3000);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(1000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);  //左键松开    Sleep(1000);    keybd_event(&#x27;K&#x27;, 0, 0, 0);    keybd_event(&#x27;K&#x27;, 0, 2, 0);    keybd_event(&#x27;K&#x27;, 0, 0, 0);    keybd_event(&#x27;K&#x27;, 0, 2, 0);    Sleep(2000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(2000);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i++);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(2000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);    keybd_event(&#x27;L&#x27;, 0, 0, 0);    keybd_event(&#x27;L&#x27;, 0, 2, 0);    keybd_event(&#x27;L&#x27;, 0, 0, 0);    keybd_event(&#x27;L&#x27;, 0, 2, 0);    Sleep(1000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(2000);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i++);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(2000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);    keybd_event(&#x27;M&#x27;, 0, 0, 0);    keybd_event(&#x27;M&#x27;, 0, 2, 0);    keybd_event(&#x27;M&#x27;, 0, 0, 0);    keybd_event(&#x27;M&#x27;, 0, 2, 0);    Sleep(1000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(2000);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i++);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(2000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);    keybd_event(&#x27;N&#x27;, 0, 0, 0);    keybd_event(&#x27;N&#x27;, 0, 2, 0);    keybd_event(&#x27;N&#x27;, 0, 0, 0);    keybd_event(&#x27;N&#x27;, 0, 2, 0);    Sleep(1000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(2000);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i++);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(2000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);    keybd_event(&#x27;O&#x27;, 0, 0, 0);    keybd_event(&#x27;O&#x27;, 0, 2, 0);    keybd_event(&#x27;O&#x27;, 0, 0, 0);    keybd_event(&#x27;O&#x27;, 0, 2, 0);    Sleep(1000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(2000);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i++);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(2000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);    keybd_event(&#x27;P&#x27;, 0, 0, 0);    keybd_event(&#x27;P&#x27;, 0, 2, 0);    keybd_event(&#x27;P&#x27;, 0, 0, 0);    keybd_event(&#x27;P&#x27;, 0, 2, 0);    Sleep(1000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(2000);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i++);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(2000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);    keybd_event(&#x27;Q&#x27;, 0, 0, 0);    keybd_event(&#x27;Q&#x27;, 0, 2, 0);    keybd_event(&#x27;Q&#x27;, 0, 0, 0);    keybd_event(&#x27;Q&#x27;, 0, 2, 0);    Sleep(1000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(2000);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i++);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(2000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);    keybd_event(&#x27;R&#x27;, 0, 0, 0);    keybd_event(&#x27;R&#x27;, 0, 2, 0);    keybd_event(&#x27;R&#x27;, 0, 0, 0);    keybd_event(&#x27;R&#x27;, 0, 2, 0);    Sleep(1000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(2000);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i++);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(2000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);    keybd_event(&#x27;S&#x27;, 0, 0, 0);    keybd_event(&#x27;S&#x27;, 0, 2, 0);    keybd_event(&#x27;S&#x27;, 0, 0, 0);    keybd_event(&#x27;S&#x27;, 0, 2, 0);    Sleep(1000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(2000);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(2000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);    keybd_event(&#x27;T&#x27;, 0, 0, 0);    keybd_event(&#x27;T&#x27;, 0, 2, 0);    keybd_event(&#x27;T&#x27;, 0, 0, 0);    keybd_event(&#x27;T&#x27;, 0, 2, 0);    Sleep(1000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    Sleep(3000);    keybd_event(VK_CAPITAL, 0, 0, 0);    keybd_event(VK_CAPITAL, 0, 2, 0);    system(&quot;taskkill /f /im msedge.exe&quot;);    printf(&quot;第六阶段结束\\n\\n&quot;);    printf(&quot;第七阶段开始\\n\\n&quot;);    Sleep(2000);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i++);    keybd_event(VK_CAPITAL, 0, 0, 0);    keybd_event(VK_CAPITAL, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(3000);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(1000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);  //左键松开    Sleep(1000);    keybd_event(&#x27;U&#x27;, 0, 0, 0);    keybd_event(&#x27;U&#x27;, 0, 2, 0);    keybd_event(&#x27;U&#x27;, 0, 0, 0);    keybd_event(&#x27;U&#x27;, 0, 2, 0);    Sleep(2000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(2000);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i++);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(2000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);    keybd_event(&#x27;V&#x27;, 0, 0, 0);    keybd_event(&#x27;V&#x27;, 0, 2, 0);    keybd_event(&#x27;V&#x27;, 0, 0, 0);    keybd_event(&#x27;V&#x27;, 0, 2, 0);    Sleep(1000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(2000);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i++);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(2000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);    keybd_event(&#x27;W&#x27;, 0, 0, 0);    keybd_event(&#x27;W&#x27;, 0, 2, 0);    keybd_event(&#x27;W&#x27;, 0, 0, 0);    keybd_event(&#x27;W&#x27;, 0, 2, 0);    Sleep(1000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(2000);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i++);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(2000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);    keybd_event(&#x27;X&#x27;, 0, 0, 0);    keybd_event(&#x27;X&#x27;, 0, 2, 0);    keybd_event(&#x27;X&#x27;, 0, 0, 0);    keybd_event(&#x27;X&#x27;, 0, 2, 0);    Sleep(1000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(2000);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i++);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(2000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);    keybd_event(&#x27;Y&#x27;, 0, 0, 0);    keybd_event(&#x27;Y&#x27;, 0, 2, 0);    keybd_event(&#x27;Y&#x27;, 0, 0, 0);    keybd_event(&#x27;Y&#x27;, 0, 2, 0);    Sleep(1000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    ShellExecuteA(0, &quot;open&quot;, &quot;https://www.bing.com&quot;, 0, 0, 1);    Sleep(2000);    printf(&quot;手机端 - 执行第%d次\\n&quot;, i++);    keybd_event(VK_F12, 0, 0, 0);    keybd_event(VK_F12, 0, 2, 0);    Sleep(2000);    SetCursorPos(300, 50);    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);    keybd_event(&#x27;Z&#x27;, 0, 0, 0);    keybd_event(&#x27;Z&#x27;, 0, 2, 0);    keybd_event(&#x27;Z&#x27;, 0, 0, 0);    keybd_event(&#x27;Z&#x27;, 0, 2, 0);    Sleep(1000);    keybd_event(VK_RETURN, 0, 0, 0);    keybd_event(VK_RETURN, 0, 2, 0);    Sleep(4000);    keybd_event(VK_CAPITAL, 0, 0, 0);    keybd_event(VK_CAPITAL, 0, 2, 0);    system(&quot;taskkill /f /im msedge.exe&quot;);    printf(&quot;第七阶段结束\\n\\n&quot;);    printf(&quot;程序执行完成&quot;);    Sleep(3000);&#125;\n\n\n\n第一版 - 废弃#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;windows.h&gt;int main() &#123;    HWND hWnd = GetForegroundWindow();    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;运行时间约五分种\\n&quot;);    Sleep(1800);    int i = 1;    printf(&quot;第一阶段执行\\n&quot;);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=行宫&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=登鹳雀楼&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=新嫁娘词&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=白居易&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=岑参&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=常建&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=陈陶&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=陈子昂&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=崔颢&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=崔曙&quot;);    Sleep(1800);    system(&quot;taskkill /f /im msedge.exe&quot;);    printf(&quot;第一阶段结束\\n\\n&quot;);    printf(&quot;第二阶段开始\\n&quot;);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=崔涂&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=戴叔伦&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=杜甫&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=杜牧&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=杜审言&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=杜荀鹤&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=高适&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=顾况&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=韩翃&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=韩偓&quot;);    Sleep(1800);    system(&quot;taskkill /f /im msedge.exe&quot;);    printf(&quot;第二阶段结束\\n\\n&quot;);    printf(&quot;第三阶段开始\\n&quot;);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=韩愈&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=贺知章&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=皇甫冉&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=贾岛&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=金昌绪&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=李白&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=李端&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=李频&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=李颀&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=李商隐&quot;);    Sleep(1800);    system(&quot;taskkill /f /im msedge.exe&quot;);    printf(&quot;第三阶段结束\\n\\n&quot;);    printf(&quot;第四阶段开始\\n&quot;);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=李益&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=刘长卿&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=刘方平&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=刘昚虚&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=刘禹锡&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=柳中庸&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=柳宗元&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=卢纶&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=骆宾王&quot;);    Sleep(1200);    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);    printf(&quot;执行第%d次\\n&quot;, i++);    system(&quot;start https://cn.bing.com/search?q=马戴&quot;);    Sleep(1200);    system(&quot;taskkill /f /im msedge.exe&quot;);    printf(&quot;第四阶段结束\\n\\n&quot;);    printf(&quot;执行完成&quot;);    Sleep(3000);&#125;\n\n下载第一版：点击下载\n第二版：点击下载\n第三版：点击下载\n第四版：点击下载\n","categories":["随记"],"tags":["代码","C语言","脚本"]},{"title":"Win10小知识","url":"/2022/08/08/%E9%9A%8F%E8%AE%B0/Win10%E5%B0%8F%E7%9F%A5%E8%AF%86/","content":"系统启动时自动创建系统还原点\n此操作时在Windows10上进行操作,其他系统未知\n\n启动系统还原功能\n打开搜索（Win+Q）输入创建还原点\n如果系统保护选项卡——保护设置中的保护功能被设置为关闭状态——请选中系统盘并点击配置按钮\n在弹出窗口中选择启用系统保护——点击应用——再点击确定\n\n禁用还原点创建频率算法根据还原点创建频率算法，如果系统在 24 小时之内创建过还原点，则Windows 10不会再主动创建其它还原点\n现在禁用该算法\n\n使用Windows + R快捷键打开 运行 ——执行regedit打开注册表编辑器\n\n找到如下地址\n\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SystemRestore\n\n\n\n右击SystemRestore文件夹——新建一个名为 SystemRestorePointCreationFrequency 的 DWORD（ 32 位 ）值——将其值设置为 0 并点击确定\n\n\n完成这些步骤后，重新启动计算机\n\n\n在系统启动时创建还原点\n打开搜索（Win+Q）输入任务计划程序\n\n右击任务计划程序库——选择创建任务\n\n在常规选项卡中填入一个任务名称（自定义）；在安全选项区域下选择不管用户是否登录都要运行——再勾选使用最高权限运行\n\n\n选择触发器选项卡——点击新建按钮\n\n\n在开始任务列表中选择启动时——点击确定按钮\n\n\n选择操作选项卡——点击新建按钮\n\n\n在开始任务列表中选择启动程序；在程序或脚本中填入powershell.exe；在添加参数（可选）中填入如下命令\n-ExecutionPolicy Bypass -Command &quot;Checkpoint-Computer -Description \\&quot;My Restore Point Startup\\&quot; -RestorePointType \\&quot;MODIFY_SETTINGS\\&quot;&quot;\n\n\n\n选择条件选项卡——清除电源区域下的 2 个选项\n\n\n点击确定——输入账号密码(账号默认就有，密码就是你的开机密码，没有的话设置一个)\n\n\n\n然后就成功了，每次开机就会创建还原点\n批量添加删除和修改后缀名添加后缀名\n先创建一个文本文档\n\n然后在输入以下文本\nsetlocal enabledelayedexpansionfor /f &quot;delims=&quot; %%i in (&#x27;dir /b&#x27;) do ren &quot;%%i&quot; &quot;%%i&quot;.XXXpause\n\n\n\n\n.XXX就是要添加上去的后缀名\n\n\n输入完之后保存并将后缀改为.bat\n\n\n删除后缀名\n先创建一个文本文档\n\n然后在输入以下文本\nren *.XXX *.\n\n\n.XXX就是要删除的后缀名\n\n\n输入完之后保存并将后缀改为.bat\n\n\n\n用的时候只需要创建一个文件夹，把要添加的后缀的文件放入里面，再把创建的.bat文件也放入里面，双击之后进行添加后缀\n\n修改后缀名@echo offset a=0setlocal EnableDelayedExpansionfor %%n in (*.XXX) do (set /A a+=1ren &quot;%%n&quot; &quot;!a!.SSS&quot;)\n\n\n.XXX是要进行改变的后缀名\n.SSS是将要改变成的后缀名\n\n这个和上面的区别就是，上面的添加后缀名是在原本的后缀名之后再添加一个后缀名，而这个就是直接修改原本的后缀名，并且运行完后不仅后缀名会改变，而且文件名也会改变（从1开始计数）\nwin10任务栏完全透明注意: 此操作是在注册表中进行,请勿乱动表中文件,否则后果自负\n\nWin+R输入regedit，打开注册表编辑器\n找到路径：HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced\n新建DWORD32，名称为TaskbarAcrylicOpacity，右键修改十进制值为0透明（0-10自行选择,数值越高,透明度越低）\n打开任务管理器（Ctrl+Shift+ESC），找到Windows资源管理器，重新启动\n\n开始菜单磁贴开始菜单磁贴中是不能直接加入文件(.txt .bat .exe …)的,但不是不能添加\n在这个C:\\Users\\你的名称\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs目录中添加上所需文件,就会可以在最近添加一列找到文件\n然后右键文件,点击固定到”开始”屏幕\n截图注意:截图前确保打开设置里面的 使用PrtScn按键打开屏幕截图\nwin+PS(PrtScn)截图直接保存到图片里面的屏幕截图文件夹\n单独点击PS(PrtScn)会进行截图,不过不会保存到文件夹里面,可以通过粘贴到画图 3D,QQ,微信…来进行保存\n","categories":["随记"],"tags":["小知识","系统"]},{"title":"cloudflared内网穿透","url":"/2023/09/27/%E9%9A%8F%E8%AE%B0/cloudflare%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","content":"Cloudflared Zero TrustZero Trust是Cloudflare公司推出的一项企业级虚拟网关服务，官方对其介绍如下：\n\nCloudflare Zero Trust是一个安全框架，旨在通过验证和保护所有的网络访问（无论用户或地点）来保护组织免受网络威胁。该框架基于 “不信任任何人 “的原则，这意味着所有访问请求在被批准之前必须经过验证和授权。\nZero Trust “旨在提供一种全面的安全方法，涵盖一个组织的网络和基础设施的所有方面。这包括用户认证、设备安全、网络分段和应用安全。\nZero Trust的主要好处之一是它能够提供细化的访问控制，使企业能够根据用户角色和权限限制对敏感资源的访问。这可以通过最小化攻击面和限制任何潜在漏洞的影响来帮助防止数据泄露和其他安全事件。\nCloudflare Zero Trust是一项基于云的服务，可以很容易地与组织的现有安全基础设施集成。它的设计具有可扩展性和灵活性，允许企业定制框架，以满足其特定需求和要求。\n（通过DeepL翻译）\n\n本文仅使用其中的tunnel功能，对其余功能不做赘述\n准备工作\n一个域名（通过阿里云等购买然后解析到Cloudflare上）\n一个Cloudflare账号\n一台设备（本文使用的系统是centos 7）\n一张双币信用卡（到后面需要验证，但是可能也不需要，因为我第一次使用tunnel的时候要信用卡验证，但是等我第二次用的时候就不需要了）\n\n\n一共有两种操作方式，一个网页版操作，一个是本地指令操作\n下面所作的一切操作的前提就是上面的已经准备好了\n在此说一下，除了http/https协议外，像是其他的tcp/ssh…这些协议是需要端对端的链接映射端口的\n\n网页版初始化登录之后点击左边的Zero Trust\n\n来到这个页面，点击Access-&gt;Tunnel\n\n这里的xnj是我之前做的，所以忽略，之后点击页面的新建，就是哪个蓝色的按钮\n\n这里是输入这个隧道的名称，随便输入就行，之后就到了这个页面，根据自己的系统选就行，我是Linux所以选那个企鹅，因为下面两个框，要是第一次使用的话就选左边的框，里面因为是要从GitHub上下载东西，但是GitHub在国内经常抽风，所以需要一个节点来加速\n\n#原链接curl -L --output cloudflared.rpm https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-x86_64.rpm &amp;&amp; sudo yum localinstall -y cloudflared.rpm &amp;&amp; sudo cloudflared service install eyJhIjoiNzQ0MTMwNW0IjoiNmM5ZDU0YzAtZDAyYS00MDJlLThlYjktZTdmMzg1YzRmkRnd0xUbGhOR1F0TjJKbU5tSTFPVGhsWTJFNCJ9#新链接curl -L --output cloudflared.rpm https://ghjs.ximuliunian.top/https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-x86_64.rpm &amp;&amp; sudo yum localinstall -y cloudflared.rpm &amp;&amp; sudo cloudflared service install eyJhIjoiNzQ0MTMwNW0IjoiNmM5ZDU0YzAtZDAyYS00MDJlLThlYjktZTdmMzg1YzRmkRnd0xUbGhOR1F0TjJKbU5tSTFPVGhsWTJFNCJ9\n\n就是https://ghjs.ximuliunian.top这个链接，然后把链接复制到终端加速下载\n\n看到这个就是代表安装好了，然后回到网页看看是否成功，如果在链接的下面看到有显示数据或者退出去隧道状态显示绿色就代表🆗了\n\n然后滑倒下面，点击右下角的next\n操作\n这个是让你输入对应内容进行穿透，按照图片提示输入即可\n\n在这里再次说一下，除了http/https协议外，像是其他的tcp/ssh…这些协议是需要端对端的链接映射端口的，这个稍后说\n\n在里面填的映射端口，要是http/https协议的话是可以直接游览器访问的，这些就可以让家里不用的设备去用来做网站什么的，除了速度慢一点，其他一切都好\n可以在一条隧道里面添加多条数据使用，但是毕竟是免费版的，所以会有条数限制具体就不再演示\n指令版下载curl -L --output cloudflared.rpm https://ghjs.ximuliunian.top/https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-x86_64.rpm &amp;&amp; sudo yum localinstall -y cloudflared.rpm\n\n把这个复制到控制台上，然后运行开始下载，链接跟上面的一样，只不过这是优化后的链接和没有第三行绑定内容\n软件默认安装到：/usr/local/bin目录下\n身份认证使用Argo Tunnel Client 需要使用者登录 Cloudflare 账号以进行授权\ncloudflared tunnel login\n\n\n出现上图内容之后复制其中的链接到本地游览器进行登录认证操作，成功之后就会出现下图\n\n本地也会进行相应的操作如下图，大致意思就是登录成功，已经在 /root/.cloudflared/ 目录下生成了cert.pem一个文件，这个文件差不多就是类似于认证证书什么的，反正很重要\n\n新建 Tunnel#样品cloudflared tunnel create [名字]#例子 如我想创建一个名为 test 的Tunnelcloudflared tunnel create test\n\n运行之后就会就会在/root/.cloudflared/目录下生成一个隧道凭据（是json文件），同时还有隧道ID（就是json文件的名字），这个东西很重要，千万不能丢\n\n配置DNS记录有两种方法进行配置，第一种方法就是直接去网站里面进行配置，第二种就是指令配置\n网站配置进入到你的网站解析页面，新建一条记录就如下面这让\n\n类型：CNAME\n名称：随便填\n目标：创建隧道的ID.cfargotunnel.com\n其他默认就好点击保存就好了\n指令配置还是打开终端，然后按照下面的格式输入指令\ncloudflared tunnel route dns [隧道的ID] [想要绑定的域名或二级域名]\n\n出现下图情况就是绑定成功了\n\n配置文件编写\n参考：本地管理的隧道 ·Cloudflare 零信任文档\n\n在/root/.cloudflared/目录下创建一个名为config.yml的文件，使用vi命令进行创建和编写\n\nvim 是一个兼容 vi 的文本编辑器，通常用来编辑纯文本。 vi 文件名 命令可以编辑一个文件，若文件名不存在则会新建\n\n在目录下使用vi config.yml，进入页面后点击I键进入书写模式并写入以下内容，#后面的包括#可以不写\ntunnel: 隧道IDcredentials-file: /root/.cloudflared/隧道ID.jsoningress:  - hostname: [CNAME 记录名称].[接入 CLoudflare 的域名]  #域名，就是相面配置的DNS域名    service: hello_world\t#这里面就是本地映射的端口，这里写这个是为了判断是否配置成功  - service: http_status:404\t#不管上面怎么设置，下面永远是这一条，否则就出错\n\n这个可以配置多个，只需要配置相对应的DNS在上面多添加一条记录即可，格式如下\ningress:  - hostname: [CNAME 记录名称].[接入 CLoudflare 的域名]      service: http://localhost:80  - hostname: [CNAME 记录名称].[接入 CLoudflare 的域名]    service: tcp://0.0.0.0:25565  - hostname: [CNAME 记录名称].[接入 CLoudflare 的域名]    service: ssh://0.0.0.0:22  - service: http_status:404\t\n\n写完之后点击键盘左上角的ESC键，然后输入:wq保存并退出，这样就会有config.yml文件了\n执行 Tunnelcloudflared tunnel --config [配置文件路径] run#如果在 .cloudflared目录下，那么执行下面语句cloudflared tunnel --config config.yml run\n\n如果不指定配置文件路径，cloudflared 会默认读取 ~/.cloudflared/config.yml\n别管报错的有多离谱，只要上面配置对了，那么基本上就没问题，报错那就多运行几次，直到运行到隧道为状态绿色为止\n\n\n这就代表是成功了，访问一下你刚才绑定的域名，如果你用的是hello_world那么你访问的结果会是下图\n\n但是还没完，还要把这个搞成Linux服务\n服务安装服务cloudflared service install\n\n他会在/etc/systemd/system目录下创建3个文件（cloudflared.service、cloudflared-update.service、cloudflared-update.timer），会在 /etc/cloudflared 目录下创建config.yml文件\n安装好之后会有下图情况\n\n大概意思就是，/root/.cloudflared/config.yml和/etc/cloudflared/config.yml存在冲突，要么删除 /etc/cloudflared目录下的config.yml文件，要么运行一下 cloudflared --config /etc/cloudflared/config.yml service install这个指令（应该是用于区分作用）\n\n此时他的服务默认路径不是咱在root下创建的文件，而是运行的etc下的文件\n\n上面这个这个咱不用管，咱只需要把路径调试对即可，因为安装服务的时候在/etc/systemd/system目录下创建了三个文件，其中有一个cloudflared.service文件，用编译器打开它，在第8行左右的位置更改一下内容\n#格式ExecStart=/usr/bin/cloudflared --no-autoupdate --config config文件路径 tunnel run#原内容ExecStart=/usr/bin/cloudflared --no-autoupdate --config /etc/cloudflared/config.yml tunnel run#新内容ExecStart=/usr/bin/cloudflared --no-autoupdate --config /root/.cloudflared/config.yml tunnel run\n\n然后就OK了，如果此时服务以运行，那么就进行重启服务即可，如遇到报错内容，根据内容进行输入即可\n\n启动服务#启动服务systemctl start cloudflared#查看服务状态（可选）systemctl status cloudflared#重启服务（更新后数据后重启一下）systemctl restart cloudflared\n\n查看是否OK通过端对端的映射可以看到，ssh已经是映射成功了，其他协议也可以这样搞\n\nWindows使用在windows系统（以下简称win）中也需要内穿，比如测试程序、穿透某项服务等。在win中操作方式跟linux大差不差，首先需要下载相对应的软件在GitHub中有两种软件一种是后缀为 msi 的安装程序，还有一个是 exe 的程序，我使用的是exe程序。至于区别以下为GPT的答案\n\ncloudflared-windows-amd64.msi 和 cloudflared-windows-amd64.exe 是两种不同的文件格式，通常用于在 Windows 操作系统上安装应用程序或工具。这两个文件的区别在于它们的安装方式和功能：\n\ncloudflared-windows-amd64.msi:\n\n\n.msi 文件是 Windows Installer 包的文件扩展名，通常用于安装程序。当您双击运行一个 .msi 文件时，Windows Installer 将会启动安装向导，引导您完成安装过程。这种文件格式通常提供更多的安装选项和设置，例如选择安装路径、添加桌面快捷方式等。\ncloudflared-windows-amd64.msi 文件可能是 Cloudflared 工具的安装程序，通过运行这个文件，您可以按照安装向导的指示在 Windows 系统上安装 Cloudflared 工具。\n\n\ncloudflared-windows-amd64.exe:\n\n\n.exe 文件是 Windows 可执行文件的常见扩展名，它们通常是独立的可执行程序。当您运行一个 .exe 文件时，它会直接执行其中的程序代码，而无需通过安装向导。\ncloudflared-windows-amd64.exe 文件可能是 Cloudflared 工具的独立可执行文件。通过运行这个文件，您可以直接启动 Cloudflared 工具，而无需进行安装过程。\n\n因此，如果您想要安装 Cloudflared 工具并在系统中进行设置，您可以选择运行 .msi 文件以启动安装向导。如果您只是想要快速运行 Cloudflared 工具而不需安装，您可以选择运行 .exe 文件。\n\n操作首先穿透的时候不是使用网页版的，而是使用本地配置文件的方式进行（跟以上指令版很像），首先建议配一下环境变量（如果你知道如何操作的话不配也行），然后打开命令窗口输入以下命令进行授权操作\ncloudflared login\n\n完成授权之后会在 C:\\Users\\%USERNAME%\\.cloudflared 目录中生成登录凭证，之后才可以进行后续的操作\n创建隧道（&lt;NAME&gt; 处写上隧道名）\ncloudflared tunnel create &lt;NAME&gt;\n\n创建隧道完成还是会在 C:\\Users\\%USERNAME%\\.cloudflared 目录下生成隧道的凭据是一个名是UUID的json文件\n然后配置穿透需要的域名\ncloudflared tunnel route dns &lt;隧道ID&gt; &lt;域名&gt;\n\n隧道ID就是生成的UUID，域名是二级域名，建议使用泛解析，可以不需要重复的进行域名绑定操作如：*.xxx.com\n然后编写配置文件，在你存放exe程序的文件夹中创建一个 config.yaml 文件，然后开始编辑内容，如下：\n# 隧道的标识 - UUIDtunnel: 隧道的UUID# 隧道的凭据credentials-file: C:\\Users\\用户名\\.cloudflared\\隧道凭据.json# 穿透的内容 - 可以有多个ingress:  # 服务1  - hostname: fw1.xxx.top # 域名    service: http://localhost:8080 # 本机服务  # 服务2  - hostname: fw2.xxx.top    service: http://localhost:9527  # 默认错误404 - 一定要有这个 - 最后一个入口规则必须是与所有流量匹配的 catch-all 规则  - service: http_status:404\n\n对上面的配置按照提示进行修改，在上面的服务中域名有fw1和fw2两个甚至可能更多，配置一个域名的泛解析之后会非常方便的进行穿透不需要一直进行创建DNS记录，但是也有一个弊端就是如果二级域名重复会导致冲突\n\n在编写这种 yaml 格式的文件需要注意缩进\n\n启用穿透创建一个cmd文件如：开启穿透.cmd，对文件继续编辑，输入以下内容\ncloudflared --config=D:\\cloudflared\\config.yaml tunnel run\n\n其中 --config= 后面的内容写上配置文件的全路径然后保存，最后双击文件即可开始穿透\n速度在DNS中有泛解析的一条数据，这条数据默认是开启DNS代理的，这个建议不要关，因为关闭的话链接超时的概率会非常大，这是开启的情况下进行 ping 10次的速度\n正在 Ping xxx.ximuliunian.top [172.67.178.240] 具有 32 字节的数据:来自 172.67.178.240 的回复: 字节=32 时间=193ms TTL=1来自 172.67.178.240 的回复: 字节=32 时间=209ms TTL=1来自 172.67.178.240 的回复: 字节=32 时间=191ms TTL=1来自 172.67.178.240 的回复: 字节=32 时间=189ms TTL=1来自 172.67.178.240 的回复: 字节=32 时间=192ms TTL=1来自 172.67.178.240 的回复: 字节=32 时间=186ms TTL=1来自 172.67.178.240 的回复: 字节=32 时间=185ms TTL=1来自 172.67.178.240 的回复: 字节=32 时间=185ms TTL=1来自 172.67.178.240 的回复: 字节=32 时间=193ms TTL=1来自 172.67.178.240 的回复: 字节=32 时间=197ms TTL=1172.67.178.240 的 Ping 统计信息:    数据包: 已发送 = 10，已接收 = 10，丢失 = 0 (0% 丢失)，往返行程的估计时间(以毫秒为单位):    最短 = 185ms，最长 = 209ms，平均 = 192ms\n\n常用指令创建隧道：\ncloudflared.exe tunnel create &lt;tunnel_name&gt;\n\n通过此命令可以创建一个新的隧道，&lt;tunnel_name&gt; 是您为隧道指定的名称。\n启动隧道：\ncloudflared.exe tunnel run &lt;tunnel_name&gt;\n\n使用此命令可以启动指定名称的隧道。\n停止隧道：\ncloudflared.exe tunnel stop &lt;tunnel_name&gt;\n\n通过此命令可以停止运行中的隧道。\n删除隧道：\ncloudflared.exe tunnel delete &lt;tunnel_name&gt;\n\n使用此命令可以删除指定的隧道。\n列出隧道：\ncloudflared.exe tunnel list\n\n该命令可以列出所有已创建的隧道。\n查看隧道状态：\ncloudflared.exe tunnel status &lt;tunnel_name&gt;\n\n通过此命令可以查看特定隧道的状态信息。\n特殊像是 tcp/rdp/ssh/smb 这一类的协议，是需要端对端的支持，什么意思呢，就是你是对Linux进行的内网穿透，你想要在Windows上进行ssh或者tcp的使用就需要在Windows上面下载一个cloudflared软件供使用，找到适合的版本下载\n下载链接：https://github.com/cloudflare/cloudflared/releases\n然后在cloudflared软件路径上进行cmd，运行cloudflared -v看看是否能正常输出版本号，能的话就可以对其及进行操作了\n\n比如我内穿了22端口到网址上那么就要在本地进行端口映射\n\n还是在然后在cloudflared软件路径上进行cmd，输入以下内容\n#样品cloudflared access 协议 --hostname 网址 --url 127.0.0.1:端口#例子cloudflared access ssh --hostname test.ximuliunian.top --url 127.0.0.1:9527\n\n出现下图中则代表把网址映射到本地的9527端口，因为映射的是Linux的ssh远程，所以可以通过ssh软件尝试连接\n\n可以看到，在本地的9527已经被映射到本地了，并且也可以被访问，\n\n同理，其他特殊协议也是这样的，就如我的世界服务器，在Linux上面开设服务器在Linux的25565端口正常开放，通过内网穿透映射到网址上，在通过上面这一串指令映射到本地，就可以进行连接\n脚本但是他要一直运行着那个黑窗口才能正常进行本地映射，那有没有什么方法可以没有这个黑窗口但是也能保持映射状态呢？\nYOU！！！\n通过我的绞尽脑汁的思考，突然灵光一现，Windows服务这个词出现在了我的脑海中，既然服务实在后台开着呢，那我是不是也可以进行保持映射状态呢，想到这里我就去试了一试，不出我所料，果然可以，然后通过着进行了c语言的脚本编写最终写完了\n注意事项可以把下载的软件和cloudflared软件这两放在一个文件夹里面\n使用软件有一个前提，那就是要使用管理员的方式打开文件，否则无法打开（可以右键软件 -&gt; 点击属性 -&gt; 点击上面的兼容性一栏 -&gt; 勾选以管理员身份运行此程序）\n\n要把cloudflared软件配置到环境变量里面（右键此电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 -&gt; 在里面找到Path这条数据进入）\n\n然后把cloudflared软件的路径复制到上面去（比如文件夹A里面就有cloudflared软件，那么从文件夹A开始包括A往上到盘符的路径复制下来），然后点击环境变量里面的新建，把路径复制到上面去\n如何判断环境变量是否配置成功了，在任何地方cmd然后输入cloudflared -v都可以输出信息那么就是配置成功了\n使用软件（我自己写的）会产生一个文件config这个文件里面存放的是服务的信息，万万不可删除，有时也会有一个temp的文件出现，这个文件也不要删，切记！切记！切记！！！\n下载点击下载\n源码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;windows.h&gt;#include &lt;stdbool.h&gt;void adds();void removes();int view();void qidong();void guanbi();bool IsProcessRunAsAdmin() &#123;    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;    PSID AdministratorsGroup;    BOOL b = AllocateAndInitializeSid(            &amp;NtAuthority,            2,            SECURITY_BUILTIN_DOMAIN_RID,            DOMAIN_ALIAS_RID_ADMINS,            0, 0, 0, 0, 0, 0,            &amp;AdministratorsGroup);    if (b) &#123;        CheckTokenMembership(NULL, AdministratorsGroup, &amp;b);        FreeSid(AdministratorsGroup);    &#125;    return b == TRUE;&#125;int main() &#123;    if (!IsProcessRunAsAdmin()) &#123;        printf(&quot;请以管理员身份打开&quot;);        Sleep(3000);        return 0;    &#125;    system(&quot;title 曦暮流年 - 端口映射&quot;);    printf(&quot;\\t##########################\\n&quot;);    printf(&quot;\\t#                        #\\n&quot;);    printf(&quot;\\t#      曦 暮 流 年       #\\n&quot;);    printf(&quot;\\t#      端 口 映 射       #\\n&quot;);    printf(&quot;\\t#                        #\\n&quot;);    printf(&quot;\\t##########################\\n\\n\\n&quot;);    while (1) &#123;        printf(&quot;\\t1. 增加服务\\n&quot;);        printf(&quot;\\t2. 删除服务\\n&quot;);        printf(&quot;\\t3. 查看服务\\n&quot;);        printf(&quot;\\t4. 启用服务\\n&quot;);        printf(&quot;\\t5. 关闭服务\\n&quot;);        printf(&quot;\\t0. 退出\\n\\n&quot;);        printf(&quot;\\t作者博客：www.ximuliunian.top\\n\\n&quot;);        int a;        printf(&quot;\\t请输入数字编号：&quot;);        scanf(&quot;%d&quot;, &amp;a);        switch (a) &#123;            case 1:                adds();                break;            case 2:                removes();                break;            case 3:                view();                break;            case 4:                qidong();                break;            case 5:                guanbi();                break;            case 0:                printf(&quot;\\t感谢使用 再见！&quot;);                Sleep(2000);                exit(0);            default:                system(&quot;CLS&quot;);                printf(&quot;\\t输入的不是应有的编号哦~~~\\n&quot;);                printf(&quot;\\t请重新输入\\n\\n&quot;);        &#125;    &#125;&#125;void adds() &#123;    FILE *fp = fopen(&quot;config&quot;, &quot;a+&quot;);    if (fp == NULL) return;    char ServiceName[300];    char access[50];    char hostname[200];    char url[50];    printf(&quot;\\n\\n\\t请输入服务名字：&quot;);    scanf(&quot;%s&quot;, ServiceName);    char tempName[300] = &quot;AAA_XMLN_&quot;;    strcat(tempName, ServiceName);    strcpy( ServiceName,tempName);    printf(&quot;\\t请输入类型（tcp/rdp/ssh/smb）：&quot;);    scanf(&quot;%s&quot;, access);    printf(&quot;\\t请输入映射网址：&quot;);    scanf(&quot;%s&quot;, hostname);    printf(&quot;\\t请输入被映射的端口（如：25565）127.0.0.1:&quot;);    scanf(&quot;%s&quot;, url);    fprintf(fp, &quot;\\n%s %s %s %s&quot;, ServiceName, access, hostname, url);    char sc[1024] = &quot;sc create &quot;;    char qd[100] = &quot;net start &quot;;    strcat(qd, ServiceName);    strcat(sc, ServiceName);    strcat(sc, &quot; binPath= \\&quot;cmd.exe /c cloudflared access &quot;);    strcat(sc, access);    strcat(sc, &quot; --hostname &quot;);    strcat(sc, hostname);    strcat(sc, &quot; --url 127.0.0.1:&quot;);    strcat(sc, url);    strcat(sc, &quot;\\&quot; start= auto&quot;);    system(sc);    system(qd);    fclose(fp);&#125;void removes() &#123;    int j = view();    int a;    char name[100];    printf(&quot;\\t请输入删除序号：&quot;);    scanf(&quot;%d&quot;, &amp;a);    FILE *ffp = fopen(&quot;config&quot;, &quot;r&quot;);    FILE *fp = fopen(&quot;temp&quot;, &quot;w&quot;);    if (fp == NULL || ffp == NULL || a &lt;= 0 || a &gt; j) return;    char sc[] = &quot;sc delete &quot;;    for (int i = 1; !feof(ffp); ++i) &#123;        char f[4][100];        fscanf(ffp, &quot;%s %s %s %s&quot;, f[0], f[1], f[2], f[3]);        if (i == a) &#123;            strcpy(name, f[0]);            continue;        &#125;        fprintf(fp, &quot;\\n%s %s %s %s&quot;, f[0], f[1], f[2], f[3]);    &#125;    strcat(sc, name);    system(sc);    fclose(fp);    fclose(ffp);    system(&quot;del config&quot;);    system(&quot;ren temp config&quot;);&#125;int view() &#123;    system(&quot;CLS&quot;);    FILE *fp = fopen(&quot;config&quot;, &quot;r&quot;);    if (fp == NULL) return -1;    int j = 1;    printf(&quot;\\n\\n\\t序号\\t服务名字\\t类型\\t映射网址\\t被映射端口\\n\\n&quot;);    while (!feof(fp)) &#123;        char a[4][100];        fscanf(fp, &quot;%s %s %s %s&quot;, a[0], a[1], a[2], a[3]);        printf(&quot;\\t%d\\t&quot;, j++);        for (int i = 0; i &lt; 4; ++i) &#123;            printf(&quot;%s\\t&quot;, a[i]);        &#125;        printf(&quot;\\n\\n&quot;);    &#125;    fclose(fp);    return j;&#125;void kg(int a, int j, char sc[]);void qidong() &#123;    int j = view();    int a;    printf(&quot;\\t请输入序号：&quot;);    scanf(&quot;%d&quot;, &amp;a);    kg(a, j, &quot;net start &quot;);&#125;void guanbi() &#123;    int j = view();    int a;    printf(&quot;\\t请输入序号：&quot;);    scanf(&quot;%d&quot;, &amp;a);    kg(a, j, &quot;net stop &quot;);&#125;void kg(int a, int j, char sc[]) &#123;    char name[100];    char sp[100];    strcpy(sp, sc);    FILE *ffp = fopen(&quot;config&quot;, &quot;r&quot;);    if (ffp == NULL || a &lt;= 0 || a &gt; j) return;    for (int i = 1; !feof(ffp); ++i) &#123;        char f[5][100];        fscanf(ffp, &quot;%s %s %s %s %s&quot;, f[0], f[1], f[2], f[3], f[4]);        if (i == a) &#123;            strcpy(name, f[0]);            break;        &#125;    &#125;    strcat(sp, name);    system(sp);    fclose(ffp);&#125;\n\n","categories":["随记"],"tags":["工具","命令","Linux","CentOS 7","C语言","脚本","内网穿透","cloudflare"]},{"title":"好玩的注释","url":"/2023/05/08/%E9%9A%8F%E8%AE%B0/%E5%A5%BD%E7%8E%A9%E7%9A%84%E6%B3%A8%E9%87%8A/","content":"地址：https://github.com/Blankj/awesome-comment\n书/*** *                 .-~~~~~~~~~-._       _.-~~~~~~~~~-. *             __.&#x27;              ~.   .~              `.__ *           .&#x27;//                  \\./                  \\\\`. *         .&#x27;//                     |                     \\\\`. *       .&#x27;// .-~&quot;&quot;&quot;&quot;&quot;&quot;&quot;~~~~-._     |     _,-~~~~&quot;&quot;&quot;&quot;&quot;&quot;&quot;~-. \\\\`. *     .&#x27;//.-&quot;                 `-.  |  .-&#x27;                 &quot;-.\\\\`. *   .&#x27;//______.============-..   \\ | /   ..-============.______\\\\`. * .&#x27;______________________________\\|/______________________________`. * */\n\n\n\n计算机/*** *              ,----------------,              ,---------, *         ,-----------------------,          ,&quot;        ,&quot;| *       ,&quot;                      ,&quot;|        ,&quot;        ,&quot;  | *      +-----------------------+  |      ,&quot;        ,&quot;    | *      |  .-----------------.  |  |     +---------+      | *      |  |                 |  |  |     | -==----&#x27;|      | *      |  |  I LOVE DOS!    |  |  |     |         |      | *      |  |  Bad command or |  |  |/----|`---=    |      | *      |  |  C:\\&gt;_          |  |  |   ,/|==== ooo |      ; *      |  |                 |  |  |  // |(((( [33]|    ,&quot; *      |  `-----------------&#x27;  |,&quot; .;&#x27;| |((((     |  ,&quot; *      +-----------------------+  ;;  | |         |,&quot; *         /_)______________(_/  //&#x27;   | +---------+ *    ___________________________/___  `, *   /  oooooooooooooooo  .o.  oooo /,   \\,&quot;----------- *  / ==ooooooooooooooo==.o.  ooo= //   ,`\\--&#123;)B     ,&quot; * /_==__==========__==_ooo__ooo=_/&#x27;   /___________,&quot; * */\n\n\n\n耶/*** *                        d*##$. *  zP&quot;&quot;&quot;&quot;&quot;$e.           $&quot;    $o * 4$       &#x27;$          $&quot;      $ * &#x27;$        &#x27;$        J$       $F *  &#x27;b        $k       $&gt;       $ *   $k        $r     J$       d$ *   &#x27;$         $     $&quot;       $~ *    &#x27;$        &quot;$   &#x27;$E       $ *     $         $L   $&quot;      $F ... *      $.       4B   $      $$$*&quot;&quot;&quot;*b *      &#x27;$        $.  $$     $$      $F *       &quot;$       R$  $F     $&quot;      $ *        $k      ?$ u*     dF      .$ *        ^$.      $$&quot;     z$      u$$$$e *         #$b             $E.dW@e$&quot;    ?$ *          #$           .o$$# d$$$$c    ?F *           $      .d$$#&quot; . zo$&gt;   #$r .uF *           $L .u$*&quot;      $&amp;$$$k   .$$d$$F *            $$&quot;            &quot;&quot;^&quot;$$$P&quot;$P9$ *           JP              .o$$$$u:$P $$ *           $          ..ue$&quot;      &quot;&quot;  $&quot; *          d$          $F              $ *          $$     ....udE             4B *           #$    &quot;&quot;&quot;&quot;` $r            @$ *            ^$L        &#x27;$            $F *              RN        4N           $ *               *$b                  d$ *                $$k                 $F *                 $$b                $F *                  $&quot;&quot;               $F *                  &#x27;$                $ *                   $L               $ *                   &#x27;$               $ *                    $               $ */\n\n\n\n赞/*** *                   /88888888888888888888888888\\ *                   |88888888888888888888888888/ *                    |~~____~~~~~~~~~&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;| *                   / \\_________/&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;\\ *                  /  |              \\         \\ *                 /   |  88    88     \\         \\ *                /    |  88    88      \\         \\ *               /    /                  \\        | *              /     |   ________        \\       | *              \\     |   \\______/        /       | *   /&quot;\\         \\     \\____________     /        | *   | |__________\\_        |  |        /        / * /&quot;&quot;&quot;&quot;\\           \\_------&#x27;  &#x27;-------/       -- * \\____/,___________\\                 -------/ * ------*            |                    \\ *   ||               |                     \\ *   ||               |                 ^    \\ *   ||               |                | \\    \\ *   ||               |                |  \\    \\ *   ||               |                |   \\    \\ *   \\|              /                /&quot;&quot;&quot;\\/    / *      -------------                |    |    / *      |\\--_                        \\____/___/ *      |   |\\-_                       | *      |   |   \\_                     | *      |   |     \\                    | *      |   |      \\_                  | *      |   |        ----___           | *      |   |               \\----------| *      /   |                     |     ----------&quot;&quot;\\ * /&quot;\\--&quot;--_|                     |               |  \\ * |_______/                      \\______________/    ) *                                               \\___/ */\n\n\n\n狗头 - 3/*** * ░░░░░░░░░░░░░░░░░░░░░░░░▄░░ * ░░░░░░░░░▐█░░░░░░░░░░░▄▀▒▌░ * ░░░░░░░░▐▀▒█░░░░░░░░▄▀▒▒▒▐ * ░░░░░░░▐▄▀▒▒▀▀▀▀▄▄▄▀▒▒▒▒▒▐ * ░░░░░▄▄▀▒░▒▒▒▒▒▒▒▒▒█▒▒▄█▒▐ * ░░░▄▀▒▒▒░░░▒▒▒░░░▒▒▒▀██▀▒▌ * ░░▐▒▒▒▄▄▒▒▒▒░░░▒▒▒▒▒▒▒▀▄▒▒ * ░░▌░░▌█▀▒▒▒▒▒▄▀█▄▒▒▒▒▒▒▒█▒▐ * ░▐░░░▒▒▒▒▒▒▒▒▌██▀▒▒░░░▒▒▒▀▄ * ░▌░▒▄██▄▒▒▒▒▒▒▒▒▒░░░░░░▒▒▒▒ * ▀▒▀▐▄█▄█▌▄░▀▒▒░░░░░░░░░░▒▒▒ * 单身狗就这样默默地看着你，一句话也不说。 */\n\n\n\n小老鼠/*** * http://www.flvcd.com/ *  .--,       .--, * ( (  \\.---./  ) ) *  &#x27;.__/o   o\\__.&#x27; *     &#123;=  ^  =&#125; *      &gt;  -  &lt; *     /       \\ *    //       \\\\ *   //|   .   |\\\\ *   &quot;&#x27;\\       /&#x27;&quot;_.-~^`&#x27;-. *      \\  _  /--&#x27;         ` *    ___)( )(___ *   (((__) (__)))    高山仰止,景行行止.虽不能至,心向往之。 */\n\n\n\n攻城狮/*** *             ,%%%%%%%%, *           ,%%/\\%%%%/\\%% *          ,%%%\\c &quot;&quot; J/%%% * %.       %%%%/ o  o \\%%% * `%%.     %%%%    _  |%%% *  `%%     `%%%%(__Y__)%%&#x27; *  //       ;%%%%`\\-/%%%&#x27; * ((       /  `%%%%%%%&#x27; *  \\\\    .&#x27;          | *   \\\\  /       \\  | | *    \\\\/         ) | | *     \\         /_ | |__ *     (___________))))))) 攻城湿 * *        _       _ * __   _(_)_   _(_) __ _ _ __ * \\ \\ / / \\ \\ / / |/ _` |&#x27;_ \\ *  \\ V /| |\\ V /| | (_| | | | | *   \\_/ |_| \\_/ |_|\\__,_|_| |_| */\n\n\n\n经典耳光老梗/*** *                                         ,s555SB@@&amp;                           *                                      :9H####@@@@@Xi                         *                                     1@@@@@@@@@@@@@@8                        *                                   ,8@@@@@@@@@B@@@@@@8                       *                                  :B@@@@X3hi8Bs;B@@@@@Ah,                    *             ,8i                  r@@@B:     1S ,M@@@@@@#8;                  *            1AB35.i:               X@@8 .   SGhr ,A@@@@@@@@S                 *            1@h31MX8                18Hhh3i .i3r ,A@@@@@@@@@5                *            ;@&amp;i,58r5                 rGSS:     :B@@@@@@@@@@A                *             1#i  . 9i                 hX.  .: .5@@@@@@@@@@@1                *              sG1,  ,G53s.              9#Xi;hS5 3B@@@@@@@B1                 *               .h8h.,A@@@MXSs,           #@H1:    3ssSSX@1                   *               s ,@@@@@@@@@@@@Xhi,       r#@@X1s9M8    .GA981                *               ,. rS8H#@@@@@@@@@@#HG51;.  .h31i;9@r    .8@@@@BS;i;           *                .19AXXXAB@@@@@@@@@@@@@@#MHXG893hrX#XGGXM@@@@@@@@@@MS         *                s@@MM@@@hsX#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;,       *              :GB@#3G@@Brs ,1GM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B,      *            .hM@@@#@@#MX 51  r;iSGAM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8      *          :3B@@@@@@@@@@@&amp;9@h :Gs   .;sSXH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:     *      s&amp;HA#@@@@@@@@@@@@@@M89A;.8S.       ,r3@@@@@@@@@@@@@@@@@@@@@@@@@@@r     *   ,13B@@@@@@@@@@@@@@@@@@@5 5B3 ;.         ;@@@@@@@@@@@@@@@@@@@@@@@@@@@i     *  5#@@#&amp;@@@@@@@@@@@@@@@@@@9  .39:          ;@@@@@@@@@@@@@@@@@@@@@@@@@@@;     *  9@@@X:MM@@@@@@@@@@@@@@@#;    ;31.         H@@@@@@@@@@@@@@@@@@@@@@@@@@:     *   SH#@B9.rM@@@@@@@@@@@@@B       :.         3@@@@@@@@@@@@@@@@@@@@@@@@@@5     *     ,:.   9@@@@@@@@@@@#HB5                 .M@@@@@@@@@@@@@@@@@@@@@@@@@B     *           ,ssirhSM@&amp;1;i19911i,.             s@@@@@@@@@@@@@@@@@@@@@@@@@@S    *              ,,,rHAri1h1rh&amp;@#353Sh:          8@@@@@@@@@@@@@@@@@@@@@@@@@#:   *            .A3hH@#5S553&amp;@@#h   i:i9S          #@@@@@@@@@@@@@@@@@@@@@@@@@A. * * *    又看源码，看你妹妹呀！ */\n\n\n\n骷髅头/*** ************************************************************** *                                                            * *   .=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-.       * *    |                     ______                     |      * *    |                  .-&quot;      &quot;-.                  |      * *    |                 /            \\                 |      * *    |     _          |              |          _     |      * *    |    ( \\         |,  .-.  .-.  ,|         / )    |      * *    |     &gt; &quot;=._     | )(__/  \\__)( |     _.=&quot; &lt;     |      * *    |    (_/&quot;=._&quot;=._ |/     /\\     \\| _.=&quot;_.=&quot;\\_)    |      * *    |           &quot;=._&quot;(_     ^^     _)&quot;_.=&quot;           |      * *    |               &quot;=\\__|IIIIII|__/=&quot;               |      * *    |              _.=&quot;| \\IIIIII/ |&quot;=._              |      * *    |    _     _.=&quot;_.=&quot;\\          /&quot;=._&quot;=._     _    |      * *    |   ( \\_.=&quot;_.=&quot;     `--------`     &quot;=._&quot;=._/ )   |      * *    |    &gt; _.=&quot;                            &quot;=._ &lt;    |      * *    |   (_/                                    \\_)   |      * *    |                                                |      * *    &#x27;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=&#x27;      * *                                                            * *           LASCIATE OGNI SPERANZA, VOI CH&#x27;ENTRATE           * ************************************************************** */\n\n\n\n猪猪/***                               *  _._ _..._ .-&#x27;,     _.._(`)) * &#x27;-. `     &#x27;  /-._.-&#x27;    &#x27;,/ *    )         \\            &#x27;. *   / _    _    |             \\ *  |  a    a    /              | *  \\   .-.                     ; *   &#x27;-(&#x27;&#x27; ).-&#x27;       ,&#x27;       ; *      &#x27;-;           |      .&#x27; *         \\           \\    / *         | 7  .__  _.-\\   \\ *         | |  |  ``/  /`  / *        /,_|  |   /,_/   / *           /,_/      &#x27;`-&#x27; */\n\n\n\n神兽 - 3/*** * * *                                                    __----~~~~~~~~~~~------___ *                                   .  .   ~~//====......          __--~ ~~ *                   -.            \\_|//     |||\\\\  ~~~~~~::::... /~ *                ___-==_       _-~o~  \\/    |||  \\\\            _/~~- *        __---~~~.==~||\\=_    -_--~/_-~|-   |\\\\   \\\\        _/~ *    _-~~     .=~    |  \\\\-_    &#x27;-~7  /-   /  ||    \\      / *  .~       .~       |   \\\\ -_    /  /-   /   ||      \\   / * /  ____  /         |     \\\\ ~-_/  /|- _/   .||       \\ / * |~~    ~~|--~~~~--_ \\     ~==-/   | \\~--===~~        .\\ *          &#x27;         ~-|      /|    |-~\\~~       __--~~ *                      |-~~-_/ |    |   ~\\_   _-~            /\\ *                           /  \\     \\__   \\/~                \\__ *                       _--~ _/ | .-~~____--~-/                  ~~==. *                      ((-&gt;/~   &#x27;.|||&#x27; -_|    ~~-/ ,              . _|| *                                 -_     ~\\      ~~---l__i__i__i--~~_/ *                                 _-~-__   ~)  \\--______________--~~ *                               //.-~~~-~_--~- |-------~~~~~~~~ *                                      //.-~~~--\\ *                               神兽保佑 *                              代码无BUG! */\n\n\n\n神兽 - 2/*** *                  ___====-_  _-====___ *            _--^^^#####//      \\\\#####^^^--_ *         _-^##########// (    ) \\\\##########^-_ *        -############//  |\\^^/|  \\\\############- *      _/############//   (@::@)   \\\\############\\_ *     /#############((     \\\\//     ))#############\\ *    -###############\\\\    (oo)    //###############- *   -#################\\\\  / VV \\  //#################- *  -###################\\\\/      \\//###################- * _#/|##########/\\######(   /\\   )######/\\##########|\\#_ * |/ |#/\\#/\\#/\\/  \\#/\\##\\  |  |  /##/\\#/  \\/\\#/\\#/\\#| \\| * `  |/  V  V  `   V  \\#\\| |  | |/#/  V   &#x27;  V  V  \\|  &#x27; *    `   `  `      `   / | |  | | \\   &#x27;      &#x27;  &#x27;   &#x27; *                     (  | |  | |  ) *                    __\\ | |  | | /__ *                   (vvv(VVV)(VVV)vvv)                 *                        神兽保佑 *                       代码无BUG! */\n\n\n\n神兽/*** *      ┌─┐       ┌─┐ *   ┌──┘ ┴───────┘ ┴──┐ *   │                 │ *   │       ───       │ *   │  ─┬┘       └┬─  │ *   │                 │ *   │       ─┴─       │ *   │                 │ *   └───┐         ┌───┘ *       │         │ *       │         │ *       │         │ *       │         └──────────────┐ *       │                        │ *       │                        ├─┐ *       │                        ┌─┘ *       │                        │ *       └─┐  ┐  ┌───────┬──┐  ┌──┘ *         │ ─┤ ─┤       │ ─┤ ─┤ *         └──┴──┘       └──┴──┘ *                神兽保佑 *               代码无BUG! */\n\n\n\n佛祖 - 2/*** * _ooOoo_ * o8888888o * 88&quot; . &quot;88 * (| -_- |) *  O\\ = /O * ___/`---&#x27;\\____ * .   &#x27; \\\\| |// `. * / \\\\||| : |||// \\ * / _||||| -:- |||||- \\ * | | \\\\\\ - /// | | * | \\_| &#x27;&#x27;\\---/&#x27;&#x27; | | * \\ .-\\__ `-` ___/-. / * ___`. .&#x27; /--.--\\ `. . __ * .&quot;&quot; &#x27;&lt; `.___\\_&lt;|&gt;_/___.&#x27; &gt;&#x27;&quot;&quot;. * | | : `- \\`.;`\\ _ /`;.`/ - ` : | | * \\ \\ `-. \\_ __\\ /__ _/ .-` / / * ======`-.____`-.___\\_____/___.-`____.-&#x27;====== * `=---=&#x27; * ............................................. *           佛曰：bug 泛滥，我已瘫痪！ */\n\n\n\n佛祖/*** *                    _ooOoo_ *                   o8888888o *                   88&quot; . &quot;88 *                   (| -_- |) *                    O\\ = /O *                ____/`---&#x27;\\____ *              .   &#x27; \\\\| |// `. *               / \\\\||| : |||// \\ *             / _||||| -:- |||||- \\ *               | | \\\\\\ - /// | | *             | \\_| &#x27;&#x27;\\---/&#x27;&#x27; | | *              \\ .-\\__ `-` ___/-. / *           ___`. .&#x27; /--.--\\ `. . __ *        .&quot;&quot; &#x27;&lt; `.___\\_&lt;|&gt;_/___.&#x27; &gt;&#x27;&quot;&quot;. *       | | : `- \\`.;`\\ _ /`;.`/ - ` : | | *         \\ \\ `-. \\_ __\\ /__ _/ .-` / / * ======`-.____`-.___\\_____/___.-`____.-&#x27;====== *                    `=---=&#x27; * * ............................................. *          佛祖保佑             永无BUG */\n\n\n\n键盘/*** * ┌───┐   ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐ * │Esc│   │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│  ┌┐    ┌┐    ┌┐ * └───┘   └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘  └┘    └┘    └┘ * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐ * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│&amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │ * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤ * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │&#123; [│&#125; ]│ | \\ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │   │ * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │ * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│&quot; &#x27;│ Enter  │               │ 4 │ 5 │ 6 │   │ * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤     ┌───┐     ├───┼───┼───┼───┤ * │ Shift  │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│&gt; .│? /│  Shift   │     │ ↑ │     │ 1 │ 2 │ 3 │   │ * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││ * │ Ctrl│    │Alt │         Space         │ Alt│    │    │Ctrl│ │ ← │ ↓ │ → │ │   0   │ . │←─┘│ * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘ */\n\n\n\n滑稽/***                                                                     *            .,,       .,:;;iiiiiiiii;;:,,.     .,,                    *          rGB##HS,.;iirrrrriiiiiiiiiirrrrri;,s&amp;##MAS,                 *         r5s;:r3AH5iiiii;;;;;;;;;;;;;;;;iiirXHGSsiih1,                *            .;i;;s91;;;;;;::::::::::::;;;;iS5;;;ii:                   *          :rsriii;;r::::::::::::::::::::::;;,;;iiirsi,                *       .,iri;;::::;;;;;;::,,,,,,,,,,,,,..,,;;;;;;;;iiri,,.            *    ,9BM&amp;,            .,:;;:,,,,,,,,,,,hXA8:            ..,,,.        *   ,;&amp;@@#r:;;;;;::::,,.   ,r,,,,,,,,,,iA@@@s,,:::;;;::,,.   .;.       *    :ih1iii;;;;;::::;;;;;;;:,,,,,,,,,,;i55r;;;;;;;;;iiirrrr,..        *   .ir;;iiiiiiiiii;;;;::::::,,,,,,,:::::,,:;;;iiiiiiiiiiiiri          *   iriiiiiiiiiiiiiiii;;;::::::::::::::::;;;iiiiiiiiiiiiiiiir;         *  ,riii;;;;;;;;;;;;;:::::::::::::::::::::::;;;;;;;;;;;;;;iiir.        *  iri;;;::::,,,,,,,,,,:::::::::::::::::::::::::,::,,::::;;iir:        * .rii;;::::,,,,,,,,,,,,:::::::::::::::::,,,,,,,,,,,,,::::;;iri        * ,rii;;;::,,,,,,,,,,,,,:::::::::::,:::::,,,,,,,,,,,,,:::;;;iir.       * ,rii;;i::,,,,,,,,,,,,,:::::::::::::::::,,,,,,,,,,,,,,::i;;iir.       * ,rii;;r::,,,,,,,,,,,,,:,:::::,:,:::::::,,,,,,,,,,,,,::;r;;iir.       * .rii;;rr,:,,,,,,,,,,,,,,:::::::::::::::,,,,,,,,,,,,,:,si;;iri        *  ;rii;:1i,,,,,,,,,,,,,,,,,,:::::::::,,,,,,,,,,,,,,,:,ss:;iir:        *  .rii;;;5r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,sh:;;iri         *   ;rii;:;51,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.:hh:;;iir,         *    irii;::hSr,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,sSs:;;iir:          *     irii;;:iSSs:.,,,,,,,,,,,,,,,,,,,,,,,,,,,..:135;:;;iir:           *      ;rii;;:,r535r:...,,,,,,,,,,,,,,,,,,..,;sS35i,;;iirr:            *       :rrii;;:,;1S3Shs;:,............,:is533Ss:,;;;iiri,             *        .;rrii;;;:,;rhS393S55hh11hh5S3393Shr:,:;;;iirr:               *          .;rriii;;;::,:;is1h555555h1si;:,::;;;iirri:.                *            .:irrrii;;;;;:::,,,,,,,,:::;;;;iiirrr;,                   *               .:irrrriiiiii;;;;;;;;iiiiiirrrr;,.                     *                  .,:;iirrrrrrrrrrrrrrrrri;:.                         *                        ..,:::;;;;:::,,.                              */                 \n\n\n\n狗头 - 2/*** *               ii.                                         ;9ABH,           *              SA391,                                    .r9GG35&amp;G           *              &amp;#ii13Gh;                               i3X31i;:,rB1          *              iMs,:,i5895,                         .5G91:,:;:s1:8A          *               33::::,,;5G5,                     ,58Si,,:::,sHX;iH1         *                Sr.,:;rs13BBX35hh11511h5Shhh5S3GAXS:.,,::,,1AG3i,GG         *                .G51S511sr;;iiiishS8G89Shsrrsh59S;.,,,,,..5A85Si,h8         *               :SB9s:,............................,,,.,,,SASh53h,1G.        *            .r18S;..,,,,,,,,,,,,,,,,,,,,,,,,,,,,,....,,.1H315199,rX,        *          ;S89s,..,,,,,,,,,,,,,,,,,,,,,,,....,,.......,,,;r1ShS8,;Xi        *        i55s:.........,,,,,,,,,,,,,,,,.,,,......,.....,,....r9&amp;5.:X1        *       59;.....,.     .,,,,,,,,,,,...        .............,..:1;.:&amp;s        *      s8,..;53S5S3s.   .,,,,,,,.,..      i15S5h1:.........,,,..,,:99        *      93.:39s:rSGB@A;  ..,,,,.....    .SG3hhh9G&amp;BGi..,,,,,,,,,,,,.,83       *      G5.G8  9#@@@@@X. .,,,,,,.....  iA9,.S&amp;B###@@Mr...,,,,,,,,..,.;Xh      *      Gs.X8 S@@@@@@@B:..,,,,,,,,,,. rA1 ,A@@@@@@@@@H:........,,,,,,.iX:     *     ;9. ,8A#@@@@@@#5,.,,,,,,,,,... 9A. 8@@@@@@@@@@M;    ....,,,,,,,,S8     *     X3    iS8XAHH8s.,,,,,,,,,,...,..58hH@@@@@@@@@Hs       ...,,,,,,,:Gs    *    r8,        ,,,...,,,,,,,,,,.....  ,h8XABMMHX3r.          .,,,,,,,.rX:   *   :9, .    .:,..,:;;;::,.,,,,,..          .,,.               ..,,,,,,.59   *  .Si      ,:.i8HBMMMMMB&amp;5,....                    .            .,,,,,.sMr *  SS       :: h@@@@@@@@@@#; .                     ...  .         ..,,,,iM5 *  91  .    ;:.,1&amp;@@@@@@MXs.                            .          .,,:,:&amp;S *  hS ....  .:;,,,i3MMS1;..,..... .  .     ...                     ..,:,.99 *  ,8; ..... .,:,..,8Ms:;,,,...                                     .,::.83 *   s&amp;: ....  .sS553B@@HX3s;,.    .,;13h.                            .:::&amp;1 *    SXr  .  ...;s3G99XA&amp;X88Shss11155hi.                             ,;:h&amp;, *     iH8:  . ..   ,;iiii;,::,,,,,.                                 .;irHA   *      ,8X5;   .     .......                                       ,;iihS8Gi *         1831,                                                 .,;irrrrrs&amp;@ *           ;5A8r.                                            .:;iiiiirrss1H *             :X@H3s.......                                .,:;iii;iiiiirsrh *              r#h:;,...,,.. .,,:;;;;;:::,...              .:;;;;;;iiiirrss1 *             ,M8 ..,....,.....,,::::::,,...         .     .,;;;iiiiiirss11h *             8B;.,,,,,,,.,.....          .           ..   .:;;;;iirrsss111h *            i@5,:::,,,,,,,,.... .                   . .:::;;;;;irrrss111111 *            9Bi,:,,,,......                        ..r91;;;;;iirrsss1ss1111 */\n\n狗头/***                                                                           *          .,:,,,                                        .::,,,::.           *        .::::,,;;,                                  .,;;:,,....:i:          *        :i,.::::,;i:.      ....,,:::::::::,....   .;i:,.  ......;i.         *        :;..:::;::::i;,,:::;:,,,,,,,,,,..,.,,:::iri:. .,:irsr:,.;i.         *        ;;..,::::;;;;ri,,,.                    ..,,:;s1s1ssrr;,.;r,         *        :;. ,::;ii;:,     . ...................     .;iirri;;;,,;i,         *        ,i. .;ri:.   ... ............................  .,,:;:,,,;i:         *        :s,.;r:... ....................................... .::;::s;         *        ,1r::. .............,,,.,,:,,........................,;iir;         *        ,s;...........     ..::.,;:,,.          ...............,;1s         *       :i,..,.              .,:,,::,.          .......... .......;1,        *      ir,....:rrssr;:,       ,,.,::.     .r5S9989398G95hr;. ....,.:s,       *     ;r,..,s9855513XHAG3i   .,,,,,,,.  ,S931,.,,.;s;s&amp;BHHA8s.,..,..:r:      *    :r;..rGGh,  :SAG;;G@BS:.,,,,,,,,,.r83:      hHH1sXMBHHHM3..,,,,.ir.     *   ,si,.1GS,   sBMAAX&amp;MBMB5,,,,,,:,,.:&amp;8       3@HXHBMBHBBH#X,.,,,,,,rr     *   ;1:,,SH:   .A@&amp;&amp;B#&amp;8H#BS,,,,,,,,,.,5XS,     3@MHABM&amp;59M#As..,,,,:,is,    *  .rr,,,;9&amp;1   hBHHBB&amp;8AMGr,,,,,,,,,,,:h&amp;&amp;9s;   r9&amp;BMHBHMB9:  . .,,,,;ri.   *  :1:....:5&amp;XSi;r8BMBHHA9r:,......,,,,:ii19GG88899XHHH&amp;GSr.      ...,:rs.   *  ;s.     .:sS8G8GG889hi.        ....,,:;:,.:irssrriii:,.        ...,,i1,   *  ;1,         ..,....,,isssi;,        .,,.                      ....,.i1,   *  ;h:               i9HHBMBBHAX9:         .                     ...,,,rs,   *  ,1i..            :A#MBBBBMHB##s                             ....,,,;si.   *  .r1,..        ,..;3BMBBBHBB#Bh.     ..                    ....,,,,,i1;    *   :h;..       .,..;,1XBMMMMBXs,.,, .. :: ,.               ....,,,,,,ss.    *    ih: ..    .;;;, ;;:s58A3i,..    ,. ,.:,,.             ...,,,,,:,s1,     *    .s1,....   .,;sh,  ,iSAXs;.    ,.  ,,.i85            ...,,,,,,:i1;      *     .rh: ...     rXG9XBBM#M#MHAX3hss13&amp;&amp;HHXr         .....,,,,,,,ih;       *      .s5: .....    i598X&amp;&amp;A&amp;AAAAAA&amp;XG851r:       ........,,,,:,,sh;        *      . ihr, ...  .         ..                    ........,,,,,;11:.        *         ,s1i. ...  ..,,,..,,,.,,.,,.,..       ........,,.,,.;s5i.          *          .:s1r,......................       ..............;shs,            *          . .:shr:.  ....                 ..............,ishs.              *              .,issr;,... ...........................,is1s;.                *                 .,is1si;:,....................,:;ir1sr;,                   *                    ..:isssssrrii;::::::;;iirsssssr;:..                     *                         .,::iiirsssssssssrri;;:.                       */\t\t\t\n\n","categories":["随记"],"tags":["注释"]},{"title":"无绑定邮箱更改Epic绑定邮箱","url":"/2022/08/05/%E9%9A%8F%E8%AE%B0/%E6%97%A0%E7%BB%91%E5%AE%9A%E9%82%AE%E7%AE%B1%E6%9B%B4%E6%94%B9Epic%E7%BB%91%E5%AE%9A%E9%82%AE%E7%AE%B1/","content":"前言我的epic账号绑定的是谷歌邮箱，但是谷歌邮箱不知道抽什么风，不让我登陆了，一直显示的是：“Google 无法验证此账号归您所有”，我试了好久都弄不回来，老无语了，想改邮箱得要验证码，但是验证码得登录邮箱， 完事我登录不了邮箱，这就形成了死循环，现在，我教大家怎么改。\n本人亲测有效！\n方法第一步打开EPIC官网：https://www.epicgames.com/\n\n第二步点击客服\n\n第三步在这个搜索栏里随便输入点内容，然后回车搜索\n\n第四步点击那个蓝色框框里面的联系我们\n\n第五步-上要是登录epic了，显示名称那里会自己给你填上，没有登陆，需要你自己填写， 写完名称，写你现在可以用的电子邮件（我用的是微软outlook），最后填写你的问题， 这一点很重要，要详细的写，最好用英语（你可以先手写汉语再在翻译软件上翻译， 建议翻译成功的英语在通过翻译软件翻译一遍， 因为中文和英文不同，别翻译错了，或者弄错意思了）我是这样写的：\n中文： “ 我是×××（这个是写你的名字，就是你epic上填写的姓，名）， 我的账户名称是:×××（这个是你的账户名称）。我现在用的是谷歌（Gmail）邮箱。 我想把我的电子邮件改成微软（outlook）邮箱。 我的谷歌（Gmail）邮箱已经无法登陆，现在无法收取安全码。 ”\n用英文翻译过来就是； “ I’m ×××, and my account name is: ×××. I am using Google (Gmail) email now. I want to change my email to Microsoft (outlook) mailbox. I can’t log in to my Gmail mailbox, and now I can’t receive the security code. ”\n写完之后点击下面的蓝框框就可以了\n并不是非得谷歌邮箱，因为我开始用的是谷歌邮箱所已填的谷歌邮箱，更改的邮箱也可以\n\n第五步-下（到了这一步，基本上就是稳了）接着第五步-上，我是当天下午将近四点提交的，第二天凌晨2:00多就给我回消息了\n\n\n第六步收到回复后在给他回复一封邮件，当然，没有收到你就一个星期发一次，再不行，我也就没办法了，回复邮件写\n\n中文： “ 我现在用的谷歌邮件是:××××@gmail.com，我想改的邮件是:××××××@outlook.com。谢谢。 ”\n\n\n英文： “ The Google mail I am using now is: ×××××@gmail.com, and the email I want to change is: ×××××@outlook.com. Thank you. ”\n\n跟上面一样，邮箱可以改成自己想要改的\n\n第七步弄完上面的几步就差不多了，就可以等了，还是当天发，第二天凌晨才回， 这次回复是两封邮件，一封是接受你更改电子邮件修改的请求， 另一封是重置密码的邮件，改了密码登录账户你就会发现， 你的电子邮件已经改了。\n\n\n\n结尾我不知道这个适不适合你，但是，至少我是这样改的，而且成功了！\n","categories":["随记"],"tags":["小知识","邮箱"]},{"title":"游览器从输入URL到页面展示过程","url":"/2022/08/19/%E9%9A%8F%E8%AE%B0/%E6%B8%B8%E8%A7%88%E5%99%A8%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B/","content":"前言在使用游览器的时候,只要在游览器的地址栏中输入网址, 就会进入相应的网站\n他是如何进入网站的,\n期间到底发生了什么呢\nhttps和http到底有什么区别,\nDNS又是什么\nTCP连接\n等等等等……\n游览器从输入URL到页面展示主要经过七个过程\nURL 输入\nDNS 解析\n建立 TCP 连接\n发送 HTTP &#x2F; HTTPS 请求\n服务器响应请求\n游览器解析渲染页面\nHTTP 请求结束,断开 TCP 连接\n\n输入 URLURL,全称: 统一资源定位符, 用于定位互联网上的资源 俗称网址\n我们在地址栏输入网址后敲击回车,游览器会对输入信息进行判断:\n\n检查输入内容是否是一个合法的 URL 连接\n如果合法,则判断输入的 URL 是否完整;如果不完整,游览器可能会对地址进行猜测,补全地址的前缀或者后缀\n如果不合法,将输入内容作为搜索条件,使用用户设置的默认搜索引擎来进行搜索\n\n现在大部分游览器都会从历史记录、书签等地方开始查找我们输入的网址,并给出智能提示\nDNS 解析因为游览器不能直接通过域名找到对应的服务器 IP 地址,所以需要进行 DNS 解析,查找到对应的 IP 地址进行访问\n\n详细过程\n用户在游览器中输入域名,操作系统会检查游览器缓存和本地的 hosts 文件中是否有这个网址的记录,有的话就从记录里面找到对应的 IP 地址,完成域名解析\n没有的话再接着使用 TCP&#x2F;IP 参数中的设置的 DNS 服务器进行查询,如果要查询的域名包含在本地配置区域资源中,则返回结果,完成域名解析\n还没有的话再接着查本地 DNS 服务器是否缓存有该网址记录,有的话就返回解析结果,完成域名解析\n如果还没有的话, 本地 DNS 服务器会发送查询报文到根 DNS 服务器,根 DNS 服务器收到请求后, 返回顶级域 DNS 服务器地址,然后本地 DNS 服务器发送查询报文到顶级域 DNS 服务器, 顶级域 DNS 服务器收到请求后, 返回权威 DNS 服务器地址, 然后本地 DNS 服务器再发送查询报文到权威 DNS 服务器, 权威 DNS 服务器收到请求后, 返回最终的 IP 地址, 完成域名解析\n\n报文就是在各个系统之间进行请求和响应时用来交换信息的,还需要遵守规定好的格式\n更详细的请自行度娘\n建立 TCP 连接当游览器获取到服务器 IP 地址后,游览器会用一个随机的端口号向服务器 80 端口发起 TCP 连接请求这个连接请求到达服务端后,通过 TCP 三次握手,建立 TCP 的连接\nTCP 三次握手其实就是建立一个 TCP 连接,客户端与服务器交互需要 3 个数据包\n握手的主要作用就是为了确认双方的接收和发送能力是否正常,初始序列号,交换窗口大小等信息\n如图所示\n\n\n第一次握手\n客户端给服务器发送一个 SYN 报文,并进入 SYN_SENT 状态,等待服务器的确认\nSYN是同步的缩写，SYN 段是发送到另一台计算机的 TCP 数据包，请求在它们之间建立连接\n\n\n第二次握手\n服务器收到 SYN 报文, 需要给客户端发送 ACK 确认报文,同时服务器也要向客户端发送一个 SYN 报文, 所以也就是向客户端发送 SYN + ACK 报文,此时服务器进入 SYN_RCVD 状态\nACK 是“确认”的缩写。 ACK 数据包是任何确认收到一条消息或一系列数据包的 TCP 数据包\n\n\n第三次握手\n客户端收到 SYN + ACK 报文,向服务器发送确认包,客户端进入 ESTABLISHED 状态,待服务器收到客户端发送的 ACK 包也会进入 ESTABLISHED 状态,完成三次握手\nESTABLISHED 状态是表示两台机器正在传输数据\n\n\n\n更详细的请自行度娘\n为什么 TCP 采用三次握手 两次不行吗?主要因为以下几点原因\n\n确认双方的收发能力\n\nTCP 建立连接之前需要确认客户端与服务器双方的收包和发包的能力\n第一次握手：客户端发送网络包,服务端收到了 这样服务端就能得出结论:客户端的发送能力、服务端的接收能力是正常的\n第二次握手：服务端发包,客户端收到了 这样客户端就能得出结论:服务器的接收、发送能力,客户端的接收、发送能力是正常的 不过此时服务器并不能确认客户端的接收能力是否正常\n第三次握手：客户端发包,服务端收到了 这样服务端就能得出结论:客户端的接收、发送能力是正常,服务器自己的发送、接收能力正常\n所以，只有三次握手才能确认双方的接收与发送能力是否正常\n\n\n确认序列号可靠同步\n\n如果是两次握手,服务端无法确定客户端是否已经接收到了自己发送的初始序列号,如果第二次握手报文丢失,那么客户端就无法知道服务端的初始序列号,那么 TCP 的可靠性就无从谈起了\n\n\n阻止重复历史连接的初始化\n\n客户端由于某种原因发送了两个不同序号的 SYN 包,我们知道网络环境是复杂的,旧的数据包有可能先到达服务器 如果是两次握手,服务器收到旧的 SYN 就会立刻建立连接,那么就会造成网络异常\n如果是三次握手,服务器需要回复 SYN + ACK 包,客户端会对比应答的序号,如果发现是旧的报文,就会给服务器发 RST 报文,直到正常的 SYN 到达服务器后才正常连接\nRST：（Reset the connection）用于复位因某种原因引起出现的错误连接，也用来拒绝非法数据和请求。如果接收到RST位时候，通常发生了某些错误\n所以三次握手才有足够的上下文信息来判断当前连接是否是历史连接\n\n\n安全问题\n\nTCP 新建连接时,内核会为连接分配一系列的内存资源,如果采用两次握手就建立连接,那会放大 DDOS 攻击\nTCP 作为一种可靠的传输控制协议,其核心思想是既要保证数据可靠传输,又要提高传输的效率,而三次握手恰好可以满足以上两方面的需求\n\n\n\n发送 HTTP &#x2F; HTTPS 请求建立连接后就可以通过 HTTP 进行数据传输\n如果使用 HTTPS,会在 TCP 与 HTTP 之间多添加一层协议作为加密及认证的服务HTTPS 使用量 SSL 和 TLS 协议,保障了信息的安全\nSSL 协议的作用是,认证客户端和服务器,确保数据发送到正确的客户端和服务器,加密数据防止数据中途被窃取,维护数据的完整性,确保数据在传输过程中不被改变\nTSL 协议的作用是,用于在两个通信应用程序之间提供保密性和数据完整性\nTLS 协议有两层组成: TLS 记录协议和 TLS 握手协议\n服务器响应请求当游览器到 web 服务器的连接建立后,游览器会发送一个初始的 HTTP GET 请求,请求目标通常是一个 HTML 文件\n服务器收到请求后,将发回一个 HTTP 响应报文,内容包括相关响应头和 HTML 正文\n游览器解析渲染页面当游览器收到服务器响应后,开始解析并渲染页面\n不同的游览器引擎渲染过程不太一样,以谷歌为例\n\n处理 HTML 标记并构建 DOM 树\n处理 CSS 标记并构建 CSSOM 树\n将 DOM树 与 CSSOM树 合并成一个渲染树\n根据渲染树来布局,以计算每个节点的几何信息\n将各个节点渲染到屏幕上,这样就完成了页面渲染\n\nHTTP 请求结束,断开 TCP 连接渲染完成之后就可以断开 TCP 连接了\n现在的游览器页面为了优化请求的耗时,默认都会开启持久连接,也就是说,标签页关闭的时候 TCP 连接才会关闭,这个关闭的过程就是四次挥手\nTCP 四次挥手过程当我们的应用程序不需要数据通信了,就会发起断开 TCP 连接 建立一个连接需要三次握手,而断开一个连接需要经过四次挥手\n如图所示\n\n\n第一次挥手\n\n客户端发起 FIN 包,客户端进入 FIN_WAIT_1 状态, TCP 规定,及时 FIN 包不携带数据,也要消耗一个序号\nFIN表示关闭连接\n\n\n第二次挥手\n\n服务器端收到 FIN 包,发出确认包 ACK , 并带上自己的序号,服务器端进入了 CLOSE_WAIT 状态, 这个时候客户端已经没有数据要发送了, 不过服务器端有数据发送的话,客户端依然需要接收, 客户端收到服务器端发送到 ACK 后,进入了 FIN_WAIT_2 状态\n\n\n第三次挥手\n\n服务器端数据发送完毕后,向客户端发送 FIN 包,半连接状态下服务器可能又发送了一些数据,服务器此时进入了 LAST_ACK 状态\n\n\n第四次挥手\n\n客户端收到服务器的 FIN 包后,发出确认包 ACK , 此时客户端进入了 TIME_WAIT 状态,此时 TCP 连接还没有释放, 必须经过两个 MSL 后,才会进入 CLOSED 状态, 而服务器端收到客户端的确认包 ACK 后就进入了 CLOSED 状态, 可以看出服务器端结束 TCP 连接的时间要比客户端早一些\n\n\n\n为什么建立连接握手三次,关闭连接时需要四次呢?TCP 握手的时候,接收端发送 SYN + ACK 的包是将一个 ACK 和一个 SYN 合并到一个包中,所以减少了一次包的发送,三次完成握手\n对于四次挥手,因为 TCP 是全双工通信, 在主动关闭方发送 FIN 包后,接收端可能还要发送数据, 不能立即关闭服务器端到客户端的数据通道, 所以也就不能将服务器端的 FIN 包和对客户端的 ACK 包合并发送, 智能先确认 ACK ,然后服务器等到无需发送数据时在发送 FIN 包, 所以四次握手时必须是四次数据包的交互\n互联网 | 因特网 | 万维网 关系图\n    互联网(internet)\n    \n        因特网(lnternet)\n        \n            万维网(www)\n        \n    \n\n","categories":["随记"],"tags":["小知识","游览器","网页","URL"]},{"title":"白嫖office365","url":"/2023/02/08/%E9%9A%8F%E8%AE%B0/%E7%99%BD%E5%AB%96office365/","content":"白嫖永久微软Office365永久的office的好处不用多说，首先就是5T网盘（可以创建多个子账号）、Word、Excel、PPT……等微软家的软件\n活不多说，教程开始\n注册账号首先打开这个网址开发人员计划|Microsoft 365开发人员中心\n\n点击 立即加入\n然后登录你的微软账户（@outlook.com），没有的创建一个\n进入之后，选择选项\n第一个为地区 选中国（China）\n第二个为公司 随便填\n第三个为语言 选中文（要是选择其他的也行）\n第一个选项勾选，选完之后，点下一个\n\n来到第二个之后看不懂的选第四个，然后下一个\n\n来到第三个，全部选上，然后点保存\n\n设置完之后是这样的，点下一步\n\n在这里数据中心就选新加坡，距离近延迟低点，名称可以随便填，但是以后登录账号的时候，就要用这个，填完之后点继续\n\n然后到这里输入电话号码进行验证（无法正常使用的话，试试吧网址上面的zh-cn改成en-us）\n如果收不到验证码，可以用Watt Toolkit(Steam++)开启国外验证码进行试试\n也可以使用Header Editor插件\n\nHeader Editor插件：https://www.123pan.com/s/Wl35Vv-llqQh.html\n注：此插件只能用于Chromium内核的游览器，如谷歌游览器，Edge游览器，火狐游览器\n\n下载好插件后，解压压缩包，然后会得到两个文件\n\n插件使用方法就是，点开游览器的扩展界面（我这里用的是Edge），直接把扩展（.crx）拖入页面，点击添加扩展即可\n\n注；一定要把扩展页面的开发人员模式和允许来自其他应用商店的扩展这两个选项打开\n\n\n安装好之后，打开扩展\n\n点击扩展\n\n点击管理\n\n点击导入导出\n\n点击导入\n\n把解压的第二个文件HE-GoogleRedirect.json添加到里面\n\n\n导入成功之后点击下面的保存\n\n\n成功之后回到输入电话号码的那个界面进行刷新从新选取，然后输入手机号码收取验证码，输入验证码即可\n创建成功之后就好了，但是90天之后得续期\n网盘1T改5T进入网站：www.microsoft365.com\n用你刚刚创建的管理员账户进行登录然后点击右上角的9个点出现以下界面\n\n点击管理，然后点击左边栏的用户-&gt;活跃用户\n在用户名一栏找到自己的（就是登录时用的邮箱），然后击有你用户名的那一栏，直接在点OneDriver\n\n点击之后，点已使用的存储空间下面的编辑，选第二个，输入5120获得5T空间\n\nE5自动续订首先你得创建一个自动续期的子账号\n进入网址My Account\n进入到这个页面，进入方式在上面1T该5T中\n\n进入页面后，在用户管理选项卡中点击添加用户\n姓氏、名字随便填，账户名得记住\n\n输入完密码之后点下一步\n许可证那一步位置选中国，如图\n\n可选配置中角色一栏点击管理中心访问权限勾选全局读者\n\n然后点下一步，点关闭\n创建应用按照地址中教程跟着走即可\nE5 自动订阅程序[已开源]\nE5自动续订网址\n\n需要你的GitHub账号进行登录\n\n问题要是授权的时候直接用的是之前创建的那个账号，没有多余选项，下面的回答可以帮助到你\n解决方法就是先用创建的那“auto_renew”登录一下邮箱，win10自带的就行，登录后电脑上就有那个账号记录，在进行登录时就可以用“auto_renew”登陆了。主要目的是在电脑上拥有那个账号的记录，就跟你玩穿越火线用别人的号登录，那么你的手机上就已经拥有了这个账号的记录，你再玩王者荣耀的时候就可以用这个号登录，原理一样的\n","categories":["随记"],"tags":["office","微软","白嫖"]},{"title":"通过Cloudflare加速GitHub个人仓库","url":"/2023/04/19/%E9%9A%8F%E8%AE%B0/%E9%80%9A%E8%BF%87Cloudflare%E5%8A%A0%E9%80%9FGitHub%E4%B8%AA%E4%BA%BA%E4%BB%93%E5%BA%93/","content":"首先，GitHub了解点计算机的都不陌生，全球最大的同性交友平台和众多良心软件的开源地\n稍微钻研一下可以就可以发现GitHub的很多妙用，比如搭建图床、搭建博客……因为GitHub的服务器在国外，所以就导致很多时候GitHub打不开，创建的仓库访问也慢，用来建图床半天才把你的图片给加载出来或者半天才进你的博客站点，这显然不是我们想看到的结果，所以，就要说说今天的主角：Cloudflare\nCloudflare是一个全球网络 ，旨在让您连接到 Internet 的一切安全、私密、快速和可靠。保护您的网站、API 和 Internet 应用程序。保护企业网络、员工和设备。编写和部署在网络边缘运行的代码——具体可以百度搜索一下，这里不过多赘述\n通过这个Cloudflare部署之后又那些好处呢，最大的好处就是访问速度明显加快，不用在等待很长时间，毕竟等待时间最是枯燥乏味的\n废话不多说，现在开始操作\n准备工作\n本文是通过GitHub来进行演示\n\n首先你得有两个账号\n一个是GitHub的一个是Cloudflare的，注册我就不多说了以下是官网\nCloudflare\nGitHub\n部署部署之前先要又一个仓库，无论是（github.io）还是普通的仓库，只要是公共的，都可以进行部署，当然也可以直接新建一个仓库\n创建仓库\n有仓库的直接跳过这一步\n\n在GitHub主页的左上角有个如下图的按钮\n\n点New创建仓库；具体步骤如下所示\n\n创建好的仓库\n\nCloudflare部署首先登录Cloudflare点击Pages\n\n点击创建项目，在点击连接到Git，底下的两个是我之前创建部署内容，新创建的是什么都没有的\n\n到这个页面你们是要进行登录一下GitHub的，我是登录过了，所以直接演示怎么部署，而且那两个使用中就是上一张图片的两个部署情况\n\n在这里可以看到之前创建的那个仓库，点击选择仓库（出现小对钩），然后点击开始设置\n\n出现以下页面后可以改我直接默认，没问题点击保存并部署，等待即可\n\n出现如下界面代表部署成功，中间圈的那个网址是你这个仓库的站点，可以通过这个直接访问仓库内容，然后点击继续处理\n\n在这里面可以设置自定义域名，至此部署完成，第一次部署可能会要等一会才会完全部署完成\n\n这个是自动部署，只要GitHub里面内容更新，Cloudflare也会同步更新\n\n进行验证在GitHub仓库里面放了一张图片\n\n通过站点加速访问\n\n可以看到，使用的就是之前出现的站点\n","categories":["随记"],"tags":["GitHub","cloudflare"]},{"title":"VScode问题","url":"/2022/07/23/%E9%9A%8F%E8%AE%B0/VScode%E9%97%AE%E9%A2%98/","content":"VScode下载慢VScode从官网下载的时候，特别慢\n解决方法就是替换下载地址为微软中国官方的CDN加速链接\nVScode官网：https://code.visualstudio.com\n加速链接：vscode.cdn.azure.cn\n替换方法：把下载链接中的https://后面的一段替换成上面的链接即可\nVScode禁止运行脚本\n解决方法关闭所有打开的VScode窗口\n然后在底部终端执行\n\nget-ExecutionPolicy\n\n显示Restricted 表受限制,然后执行\n\nset-ExecutionPolicy RemoteSigned;\n\n在执行\n\nget-ExecutionPolicy\n\n显示RemoteSigned就可以了\n修改VScode生成的HTML的lang在使用VS code开发前端的时候输入英文“!”快捷生成HTML骨架\n但是骨架上带的 lang 是 en\n（lang&#x3D;”en” 这个意思是告诉游览器这个页面用的是英语，游览器上的自动翻译就是靠这个）\n本文就是修改 en 成为 zh-CN\n修改步骤打开VS code 并打开设置(位于屏幕左下角)\n\n搜索emmet.variables\n\n点击下面的添加项，把默认的en修改成zh-CN\n\n","categories":["随记"],"tags":["修改","编辑器"]}]